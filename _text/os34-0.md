---
title: "Многозадачное программирование"
section: os
---


### Что такое блокировка потока?

![Thread blocking](https://www.nginx.com/wp-content/uploads/2015/06/Blocking-Operation.png "Thread blocking"){: .align-center style="width: 800px;"}
Источник: [NGINX](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.nginx.com%2Fblog%2Fthread-pools-boost-performance-9x%2F&psig=AOvVaw0wHik14u0KzjbA6fRsEycs&ust=1648133124883000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCLjMhcO83PYCFQAAAAAdAAAAABAD).
{: style="text-align: center; font-size:0.7em;"}

Любая компьютерная программа - это последовательность инструкций, выполняемая на центральном процессоре. Инструкции идут одна за одной и выполняются последовательно на конвейере. Однако, довольно часто при работе программ центральному процессору приходится обращаться к внешним устройствам - оперативной памяти, жесткому диску, устройствам ввода-вывода. Все они работают очень медленно с точки зрения процессора. 

Более того, выполнение таких операций может потребовать неопределенно долгого времени. Например, если в программе встречается инструкция чтения с клавиатуры, программа должна ждать ввода пользователя. Причем, она не может продолжиться до тех пор, пока эта инструкция не будет выполнена и не будет возвращено значение. Ведь инструкции в программе идут последовательно и выполнение следующей инструкции может зависеть от результата предыдущей. Такая ситуация называется блокировкой потока. То есть, остановка потока выполнения инструкций программы.

В операционных системах для этого существует специальный механизм - системные вызовы. Как мы знаем, программа не может напрямую обращаться к внешним устройствам, она должна вызвать соответствующую функцию операционной системы. В такой момент управление переходит к ней и программа должна ожидать окончания выполнения системного вызова. 

Таким образом, при выполнении некоторых действий выполнение программы блокируется. То есть она будет ждать какое-то, заранее неопределенное время. Такие операции называются блокирующими. Примерами блокирующих операций являются:

* обращение к внешним устройствам через механизм системных вызовов;
* файловый и консольный ввод-вывод;
* выполнение сетевых запросов;
* явные инструкции ожидания (например, time.sleep в питоне);

Неблокирующими операциями являются инструкции, которые сразу же выполняются на центральном процессоре. К ним относятся математические операции, операции со строками, массивами, и другие простые манипуляции. Во время выполнения таких инструкций программа полностью загружает центральный процессор (или как минимум, одно его ядро). 

На практике, большинство прикладных программ большую часть времени своего выполнения находятся именно в таком состоянии ожидания. Это приводит к нерациональному расходованию ресурсов. И именно для решения этой проблемы в операционных системах был придуман механизм многозадачности. Операционная система сама отслеживает состояние процессов и может переключить выполнение на другой, незаблокированный процесс пока этот ждет наступления внешнего события.

{% capture notice-2 %}
Выводы:
1. Программы в своей работе часто обращаются к медленным внешним устройствам.
2. Блокирующими называются операции, которые требуют неопределенного времени.
3. Классический пример - операция чтения с консоли.
4. При выполнении блокирующей операции выполнение программы приостанавливается.
5. Выполнение не может быть продолжено до наступления какого-то внешнего события.
6. Управление передается операционной системе посредством системного вызова.
7. Большинство программ большую часть времени просто ждут.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Откуда берется прирост скорости?

В зависимости от того, насколько часто та или иная программа (а точнее ее алгоритм) выполняет блокирующие операции, все алгоритмы можно разделить на две условные категории:

![CPU and IO bound tasks](https://www.researchgate.net/profile/Anderson-Maliszewski/publication/328722843/figure/fig4/AS:688865962643462@1541249852690/I-O-and-CPU-bound-comparison.ppm "CPU and IO bound tasks"){: .align-center style="width: 800px;"}
Источник: [Maliszewski@ResearchGate](https://www.researchgate.net/publication/328722843_Performance_Characterizations_of_IaaS_Private_Clouds_for_Scientific_and_Enterprise_Workloads/figures?lo=1&utm_source=google&utm_medium=organic).
{: style="text-align: center; font-size:0.7em;"}

* задачи, ограниченные процессором (cpu-bound tasks) - это программы, большую часть которых составляют вычислительные инструкции. Такие программы редко блокируются и сильно нагружают центральный процессор. Скорость их выполнения напрямую зависит от скорости работы процессора.
* задачи, ограниченные вводом-выводом (io-bound tasks) - это такие программы, которые часто выполняют блокирующие операции, чаще всего - операции ввода-вывода. Такие программы наоборот, большую часть времени находятся в ожидании, и скорость их выполнения зависит от внешних факторов.

Надо подчеркнуть, что это характеристика самой задачи, то есть алгоритма, а не способа его решения. Если задача связана с вводом-выводом, ее нельзя сделать чисто вычислительной, и наоборот. Хотя, конечно, можно немного уменьшить или увеличить количество блокирующих операций, специальным образом спроектировав алгоритм, но в целом, именно сама решаемая задача будет определять, к какому из этих классов будет относиться программа.

Еще заметим, что данное деление, конечно, условное, и нет четкой границы между этими двумя классами. Это скорее непрерывный спектр, а эти классы - его полюса. Мы описываем его только потому, что разработчику программ полезно понимать, где в этом спектре находится его программа, так как от этого зависит, как ее выполнение можно ускорить. Ведь подходы к оптимизации таких программ существенно различаются.

Выполнение задач, ограниченных процессором, можно ускорить двумя способами. Во-первых, можно увеличить скорость процессора. Это очевидный, но не всегда возможный вариант. Во-вторых, некоторые такие задачи можно разделить на относительно независимые блоки, подзадачи, некоторые из которых можно выполнять одновременно. Такое возможно, если выполнение одного блока никак не использует результат выполнения других блоков. В таком случае, их можно выполнять одновременно, например, на разных ядрах одного процессора (или на разных процессорах, или даже машинах в кластере) и за счет этого получить прирост скорости. Такой подход называется параллелизмом или параллельным программированием.

Задачи, ограниченные вводом-выводом, сложно ускорить, используя более быстрый процессор. Это, конечно, не повредит, но такие алгоритмы только малую долю времени выполняются на нем. Здесь опять же поможет разбиение программы на независимые подзадачи. Но их уже не обязательно выполнять одновременно. Можно переключать подзадачи по мере блокировок, примерно так же как поступает операционная система с процессами. Такой подход называется асинхронное программирование. Еще вы можете встретить термин “оптимизация блокировок”.

![Concurrency vs parallelism](https://techrocks.ru/wp-content/uploads/2021/02/concurrency-vs-parallelism.jpeg "Concurrency vs parallelism"){: .align-center style="width: 800px;"}
Источник: [TechRocks.ru](https://www.google.com/url?sa=i&url=https%3A%2F%2Ftechrocks.ru%2F2021%2F02%2F13%2F10-advanced-project-ideas%2Fconcurrency-vs-parallelism%2F&psig=AOvVaw3G-0TnkXV6CS_rp-6QHgtw&ust=1648133703556000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCIDtzta-3PYCFQAAAAAdAAAAABAD).
{: style="text-align: center; font-size:0.7em;"}

Выполнение программы в таком случае, перестает быть строго последовательным. То есть мы не можем быть уверены в том, что инструкции программы выполнятся именно в той последовательности, которую мы задали при написании программы. Это немного похоже на создание программ в процедурном стиле, когда вместо написания всех инструкций в линейной последовательности, вы создаете обособленные функции, а их основного кода можете вызывать их в произвольном порядке.

![Chess simul](https://en.chessbase.com/Portals/All/2016/Carlsen_hamburg/ff/simul06.jpg "Chess simul"){: .align-center style="width: 800px;"}
Источник: [ChessBase](https://www.google.com/url?sa=i&url=https%3A%2F%2Fen.chessbase.com%2Fpost%2Fcarlsen-s-70-board-simul-in-hamburg&psig=AOvVaw2tHfwiubEdhfJDXx1zHJJO&ust=1648133585900000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCMCs-bq-3PYCFQAAAAAdAAAAABAE).
{: style="text-align: center; font-size:0.7em;"}

Еще это похоже на сеанс одновременной игры в шахматы. Гроссмейстер в этой аналогии - как процессор. Он думает быстро и его время очень ценно. А игроки - это задачи, которые часто “блокируют” его, то есть долго думают над ходом. Если бы гроссмейстер играл с каждым игроком последовательно, весь сеанс занял бы очень много времени. Поэтому на практике он не ждет окончания хода игрока, а перемещается к следующему и так далее по кругу. За исключением технических деталей, именно так и работают асинхронные программы.

Надо сказать, что в информатике существует путаница в терминах, связанных с этой темой. Не все четко понимают разницу между асинхронным и параллельным программированием. Тем более, что подзадачи тоже могут выполняться на разных ядрах. Поэтому не удивляйтесь, если в других источниках увидите другие определения асинхронности и параллелизма. Но здесь я буду использовать эти два термина для обозначения двух разных подходов к ускорению работы программ. Для общего названия практики программирования, заключающейся в разбиении алгоритма на независимые подзадачи я выбрал термин "Многозадачное программирование". Многозадачное программирование, таким образом, включает в себя и асинхронность и параллелизм.

{% capture notice-2 %}
Выводы:
1. Все алгоритмы можно поделить на две условные категории.
2. Задачи, ограниченные процессором - вычислительные, постоянно выполняются.
3. Задачи, ограниченные вводом-выводом - часто ждут внешних событий
4. Первую категорию можно ускорить только за счет параллелизма.
5. Вторую - за счет асинхронности и, в меньшей степени, за счет параллелизма.
6. В момент, когда одна задача блокируется, процессор может переключиться на другую.
7. Асинхронное программирование очень похоже на сеанс одновременной игры.
8. В терминах существует путаница. Особенно в русскоязычных.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Каковы основные недостатки многозадачного программирования?

Многозадачное программирование помогает решить насущную проблему - оптимизацию работы программ. И поэтому оно широко используется при создании сложных информационных продуктов. В первую очередь в этом подходе нуждаются сетевые приложения, так как обмен данными по сети - это блокирующие операции. Тем не менее, надо понимать, что применение многозадачного программирования порождает определенные сложности. 

Мы уже упоминали, что некоторые задачи по самой своей природе являются последовательными. Если выполнение каждой следующей инструкции требует использование результата предыдущей, то мы никак не сможет разделить программу на независимые подзадачи. Это, конечно, редкий случай, но такое может случиться. Большинство задач, все же поддаются некоторой декомпозиции.

Приведем простой пример - алгоритм решения квадратного уравнения через дискриминант. Можно разделить эту задачу на три - вычисление дискриминанта, вычисление первого корня и вычисление второго. Причем, первый этап должен быть реализован в самом начале, так как его результат используется в последующих шагах. А вот вычисления корней являются независимыми задачами, и их можно выполнять в любой последовательности и одновременно. Это, конечно, вычислительно очень простая задача, но хорошо иллюстрирует пример частично распараллеливаемого алгоритма. 

Многозадачное программирование тесно связано с реализацией механизма многозадачности. Такой механизм может реализовываться либо самой операционной системой через механизм процессов, либо библиотекой языка программирования. Многозадачность - это механизм псевдоодновременного выполнения нескольких задач (алгоритмов) на компьютере, когда система многозадачности периодически переключает выполнение одного потока команд на другой. Это называется переключение контекста. В любом случае нужно помнить о двух типах многозадачности - кооперативной и вытесняющей. при кооперативной многозадачности переключение на другую задачу происходит при блокировке текущей. При вытесняющей - система сама может переключить контекст в произвольный момент, между двумя любыми инструкциями.

Если ваши задачи являются полностью изолированными, каждая задача “не замечает” переключение контекста, ведь при возврате к выполнению этой задачи она продолжится с того же места без каких-либо побочных эффектов. Проблемы возникают, если задачи взаимосвязаны и используют какие-либо общие ресурсы. Например, общие переменные. Ведь пока задача была приостановлена, значение этой общей переменной могло поменяться, а текущая задача на это не рассчитывала. А на практике большинство задач так или иначе используют общие ресурсы - переменные (то есть общие области в памяти), файлы, внешние устройства, сеть. 

Поэтому если какой-то алгоритм работает корректно в обычном, однопоточном режиме, он может работать некорректно в многозадачном виде именно из-за таких общих ресурсов. Это называется потоконебезопасные алгоритмы. При написании многозадачных программ нам нужно следить за тем, как задачи в них взаимодействуют и обеспечивать потокобезопасность. Это дополнительные сложности, с которыми мы сталкиваемся при проектировании и реализации многозадачных программ.

Еще одна большая сложность при реализации многозадачных программ - сложность их отладки. Особенно при использовании вытесняющей многозадачности программист не может предсказать моменты переключения контекста. В результате инструкции выполняются в случайном порядке, что может приводить к ошибкам, которые то появляются, то исчезают. Ловить и исправлять такие ошибки довольно сложно.

Вместе с этим надо сказать, что распараллеливание алгоритма не является панацеей для быстродействия. Ведь переключение контекста - это сам по себе довольно длительный процесс. Конечно, обычно не приходится реализовывать собственный механизм многозадачности - есть уже готовые инструменты, но все равно, на создание задач и переключение между ними тратится время и ресурсы. Существует даже понятие чрезмерного распараллеливания, когда большая часть времени выполнения программы тратится не на выполнение полезной задачи, а на переключение между задачами.

Поэтому прирост скорости при использовании многозадачности никогда не бывает кратным. Даже если вы разбили программу на пять задач и запустили одновременно на разных ядрах процессора, не ожидайте пятикратного ускорения программы. Насколько в реальности может быть ускорена программа зависит от множества факторов, все, что мы можем сказать, что ускорение будет меньше, чем в пять раз.

Несмотря на все сложности, параллельное и асинхронное программирование - очень распространенные техники, которые зачастую помогают решить насущные проблемы разработки сетевых приложений. Часть только с помощью распараллеливания можно реализовать некоторую функциональность, которая в чисто последовательном режиме была бы просто невозможной. Например, создание сервера, который может одновременно обслуживать нескольких клиентов. Так что знание основ многозадачного программирования - необходимый навык для любого разработчика.

{% capture notice-2 %}
Выводы:
1. Некоторые задачи являются в принципе последовательными.
2. Такие программы сложнее проектировать, реализовывать и отлаживать.
3. Существует понятие потокобезопасности, которую надо обеспечивать.
4. Одновременное программирование связано с механизмами многозадачности.
5. Вытесняющая многозадачность означает непредсказуемое переключение контекста.
6. Не стоит забывать про накладные расходы - это все не бесплатно.
7. Прирост скорости даже в идеальном случае не будет кратным.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Чем отличаются процессы и потоки?

![Processes and threads](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_01_ThreadDiagram.jpg "Processes and threads"){: .align-center style="width: 800px;"}
Источник: [D. Kurtz](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.cs.uic.edu%2F~jbell%2FCourseNotes%2FOperatingSystems%2F4_Threads.html&psig=AOvVaw3i1QTDzB2kyzorvixdM_Zb&ust=1648133395634000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCPjkx8q93PYCFQAAAAAdAAAAABAD).
{: style="text-align: center; font-size:0.7em;"}

Для обеспечения многозадачности существуют известные механизмы операционной системы - процессы. Вы можете спроектировать программу так, чтобы она состояла из нескольких взаимодействующих процессов. Тогда запуском, переключением и управлением процессами займется операционная система. Здесь надо помнить два факта. Во-первых, каждый процесс является изолированным участком памяти, который имеет свой стек, собственные структуры данных, исполняемый код, и множество скрытых атрибутов. Во-вторых, все современные операционные системы реализуют именно вытесняющую многозадачность. То есть процессы могут быть приостановлены и переключены в произвольные моменты времени, вы как разработчик никак на это не можете повлиять.

Управление процессами - это прерогатива операционной системы. То есть все операции с процессами - создание, переключение, уничтожение - производится исключительно самой системой. Но на предоставляет специальные системные вызовы для того, чтобы сами процессы могли совершать необходимые действия. Например, системный вызов exec порождает новый процесс. А системный вызов exit - уничтожает текущий (этот системный вызов автоматически выполняется при достижении конца программы, фактически - это всегда последняя инструкция в любой программе). Поэтому любой процесс может запросить у операционной системы создание нового процесса. После этого в него можно загрузить определенную программу и запустить его на выполнение. Так как все эти операции осуществляются через механизм системных вызовов, они никак не зависят от языка программирования.

Но надо помнить, что все действия, связанные с переключением процессов, не имеют системных вызовов. Сами процессы никак не могут повлиять на то, когда операционная система может их приостановить. Обычные, немногопоточные программы как правило этого и не замечают, так как они возобновляют работу с того же места, для них этой приостановки как бы и не существовало. Но как только вы начинаете создавать многопоточные или многопроцессные приложения, приходится обращать внимание на этот механизм вытесняющей многозадачности. Более того, создание, переключение и уничтожение процесса - это довольно сложные и длительные операции. Кончено, с человеческой точки зрения это происходит мгновенно, много раз в секунду. Но с точки зрения компьютера это занимает довольно много времени. Поэтому операционные системы не переключают процессы очень часто. 

В рамках одного процесса могут быть организованы так называемые потоки - отдельные задачи, каждая из которых имеет собственный алгоритм работы. Потоки похожи на процессы в том, что они выполняются независимо друг от другая, "параллельно". Потоки так же могут блокироваться, ведь в ходе их выполнения могут быть выполнены блокирующие операции. Таким образом потоки тоже могут находиться либо в заблокированном состоянии, либо в состоянии готовности к выполнения, либо в состоянии выполнения в данный момент. Основная идея процессов состоит в том, что при выполнении блокирующей операции не происходит приостановки всего процесса операционной системы. Блокируется только текущий поток. Если в программе есть другие незаблокированные потоки, то есть потоки в состоянии готовности, то выполнение будет переключено на них. Это позволит не блокировать процесс целиком. Это называется оптимизация блокировок. За счет этого может произойти ускорение работы, так как программа будет меньше времени проводить в ожидании.

Любой процесс имеет как минимум один поток - главный. В процессе своего выполнения программа может создать новый поток и загрузить в него какой-то программный код. Создавать можно столько потоков, сколько необходимо. В отличие от процесса, все потоки выполняются в рамках одного процесса. Поэтому они имеют полный доступ ко всем общим ресурсам процесса - например, к переменным. Вообще, все потоки одного процесса имеют общую память - область памяти их процесса.

Вообще говоря, потоки, как и процессы - концепция операционных систем. Но на практике ни одна распространенная операционная система не поддерживает потоки на уровне ядра. Поэтому сейчас реализацией потоков занимается на ядро операционной системы (как с процессами), а внешние библиотеки. Поэтому существует множество реализаций потоков в разных библиотеках, в разных языках программирования. Мы будем изучать потоки на примере стандартной библиотеки Python, но даже в этом языке программирования существуют другие библиотеки для многопоточности. Их конкретная реализация может различаться в деталях и в механизме организации потоков. 

{% capture notice-2 %}
Выводы:
1. Для обеспечения многозадачности в операционной системе используются процессы.
6. Операции с процессами происходят через системные вызовы и не зависят от языка.
4. Создание процесса - довольно длительная процедура.
5. Процессы управляются операционной системой, у программиста нет над ними контроля.
2. Потоки выполняются в рамках одного процесса и имеют общую память.
3. Потоки сейчас не поддерживаются на уровне ядра никакими популярными ОС.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что может пойти не так?

Как мы уже говорили, при разработке обычных, немногозадачных программ не возникает никаких проблем при блокировке и переключении процессов. Так как процессы являются полностью изолированными единицами выполнения программного кода, когда процесс возобновляется, он продолжает свое выполнение в том же состоянии, на котором он остановился. Операционная система сама при переключении процесса переносит в нужные области оперативной памяти всю информацию, необходимую процессу для выполнения. 

По-другому все обстоит в работе многозадачных приложений. Дело в том, что несколько потоков выполнения могут работать с общими ресурсами. Рассмотрим такую ситуацию. Программа состоит из двух потоков. Каждый из них работает с одним и тем же файлом - осуществляет чтение и запись в него. Допустим, посередине чтения из этого файла текущий поток прервался из-за вытесняющей многозадачности. Управление переключилось на второй поток программы, который начал запись в этот файл. После этого потоки опять переключились и управление вернулось к первому. С его точки зрения, посередине чтения содержимое файла изменилось. Это может привести к непредсказуемым последствиям, так как нарушает логику работы алгоритма.

Давайте рассмотрим классический пример. Допустим, мы пишем банковское приложение для работы со счетом клиента. И у нас есть функция списания денег со счета. Она принимает один аргумент - количество денег, которые надо списать. Допустим, так же, что счет клиента - дебетовый, то есть на нем не может быть долга. Тогда наша функция должна проверять, есть ли у клиента необходимая сумма. Если да, то списываем (и возвращаем, например, True), а если нет - отказываем. Это может выглядеть примерно так:

```python
account = 100

def acquiring(amount):
	global account
	if account > amount:
		account -= amount
		return True
	else:
		return False
```

Довольно простая и абсолютно правильная логика. Наша программа будет работать без ошибок - сколько бы раз мы не вызвали функцию, счет в минус не уйдет, там стоит на это проверка. 

Но допустим, для ускорения банковского обслуживания мы хотим сделать нашу программу многопоточной - чтобы функция эквайринга платежа выполнялась в новом потоке. Таким образом, можно одновременно обрабатывать несколько платежей, ускоряя работу программы.

Конечно, на практике такая простая функция и так будет работать быстро и не сильно выиграет от многопоточности. Но на практике така функция может вполне содержать, например, несколько запросов к удаленной базе данных, которые занимают много времени и блокируют поток. Так что в реальных приложениях есть, что оптимизировать многопоточностью.
{: .notice--warning}

После введения многопоточности такая программа уже не будет работать гарантированно правильно. Допустим, у нас на счете 50 денег и мы списываем два раза по 30 денег. По идее, второе списание не должно пройти. Но вот, что может случиться. Если одновременно запущено два экземпляра этой функции, то первый поток может прерваться уже после проверки условия (проверка показала истину, так как 50 больше 30), но перед уменьшением баланса счета. В этот момент включается второй экземпляр функции, который тоже выполнит проверку, получит истинный результат, спишет деньги и закончится. А значит, выполнение вернется в первый поток, который продолжится с точно того же места, на котором прервался. То есть уже после проверки условия. И таким образом произойдет двойное списание. 

Такая ситуация называется проблемой доступа к общим ресурсам. Общим ресурсом может быть не только файл, но и какая-то область в памяти, например, переменная, потоки ввода-вывода, любые внешние устройства. Очень часто в многопоточных программах общими ресурсами выступают переменные. Если несколько потоков работают одновременно с одними переменными, то они могут изменяться без ведома какого-либо потока. 

То же самое происходит при обращении к внешним устройствам, например, к консоли. Вывод может перепутываться между потоками, нарушаться последовательность операций. В общем случае можно сказать, что проблема многопоточных программ состоит в том, что программист не может однозначно определить порядок выполнения операций в программе, состоящей из нескольких потоков. 

Программы, которые корректно работают как в однопоточном, так и в многозадачном режиме называются потокобезопасными. Потокобезопасность - это свойство алгоритмов, программ, даже структур данных, которое заключается в способности правильно работать при наличии множества потоков. Обеспечение потокобезопасносности - это обязанность программиста, который разрабатывает многопоточные программы. 

Одна из главных трудностей, с которыми встречается программист при написании многопоточных программ это то, что ошибки потокобезопасности очень трудно зафиксировать. В нашем примере со счетом двойное списание может произойти только если сложится очень определенная комбинация условий внешней среды. В какой момент произойдет переключение потока определяет операционная система исходя их множества факторов. Поэтому если мы запустим нашу программу вручную, скорее всего, все выполнится правильно. И тысячу раз все может выполняться правильно, а на тысяча первый - произойдет двойное списание. Поэтому ошибки потокобезопасности очень трудно заметить. Ведь такое двойное списание происходит и в реальности в настоящем банковском программном обеспечении, с его кучей степеней защиты, множеством стандартов и процедур тестирования.

Обеспечение потокобезопасности основывается на том, что ее нарушения возникают при доступе к общим ресурсам. Поэтому если ограничить возможность нескольких потоков одновременно обращаться к одному и тому же ресурсу, то программа станет работать корректно, так как избежит проблемы, описанной выше. Такой механизм называется блокировка ресурсов. 

{% capture notice-2 %}
Выводы:
1. Проблемы возникают, когда подзадачи обращаются к общим ресурсам. 
2. Если у потоков есть общая переменная, она может измениться без ведома потока.
3. Если несколько потоков пишут данные в один файл, вывод может быть перепутан.
4. То же самое может произойти с выводом в консоль.
5. Потокобезопасность - это свойство программы работать правильно в конкуррентном режиме.
6. Программист должен обеспечить потокобезопасность своей программы.
7. Самый понятный способ обеспечения потокобезопасности - ввести блокировки ресурсов.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Как заблокировать доступ к ресурсу?

![Locks](https://media.geeksforgeeks.org/wp-content/uploads/Mutex_lock_for_linux.jpg "Locks"){: .align-center style="width: 800px;"}
Источник: [GeeksForGeeks](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.geeksforgeeks.org%2Fmutex-lock-for-linux-thread-synchronization%2F&psig=AOvVaw0OdCj7XzrGgJtCokoE03oq&ust=1648134217788000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCMCnmMfA3PYCFQAAAAAdAAAAABAN).
{: style="text-align: center; font-size:0.7em;"}

Так как большинство проблем при работе многопоточных программ происходит при одновременном доступе нескольких потоков к одному общему ресурсу, самым решением этой проблемы будет запретить доступ нескольких потоков к одному и тому же ресурсу. Для этого существуют специальные объекты - замки, которые помогают заблокировать доступ к ресурсу.

Концептуально, замок работает очень просто. Это некоторый особый объект, у которого есть всего два действия - закрыть и открыть (обычно их называют "получить доступ", acquire и "освободить", release). При создании замок находится в состоянии "свободный". Когда какой-то поток хочет поработать с определенным ресурсом (например, общей переменной), он получает досуп к замку. Получить доступ можно только к свободному замку. В этот момент замок переходит в состояние "закрытый". Если в этот момент другой поток тоже захочет получить доступ, он не сможет, так как замок находится в состоянии "закрыт". В этот момент второй поток блокируется и начинает ждать, когда поток, закрывший замок его освободит. Таким образом, два потока не могут работать одновременно с одним и тем же ресурсом. Поток, который первый закрыл замок заставит остальные потоки, даже если он сам прервется и передаст им управление, ждать, пока он не закончит работу с ресурсом и не высвободит замок.

Замки - это предохранительный механизм, с помощью которого программист может обеспечить потокобезопасность своих программ. Для того, чтобы эта схема сработала, разработчик должен найти все места в своей многопоточной программе, в которых идет работа с общим для нескольких потоков ресурсом, и "закрыть их на замок" - поставить перед началом работы получение доступа к замку, а в конце - освобождение замка. Не нужно думать, что использование замка в одном потоке обезопасит общий ресурс независимо от того, что происходит в других. Нет, если другие потоки не проверяют замок перед началом работы с ресурсом, то программа все разно будет потоконебезопасной. 

Нужно отметить, что операции получения доступа и освобождения замка являются атомарными - потоки выполнения не могут прерваться посередине проверки. Именно поэтому, кстати, не получится обойтись "самодельными" замками. Ведь можно подумать, что такую проверку на занятость ресурса можно провести и просто условием, например так:

```python
locked = False

# thread 1
if not locked:
	global locked
	lock = True
	do_something(resource)
	lock = False

# thread 2
if not locked:
	global locked
	lock = True
	do_something_else(resource)
	lock = False
```

Этот псевдокод в принципе полностью повторяет логику работы замка. Однако, так все равно делать не нужно. Ведь мы говорим о вытесняющей многозадачности - то есть операционная система может прервать выполнение потока в произвольном месте. И вполне может случиться так, что выполнение прервется после проверки условия, но перед "закрытием" замка. Тогда второй поток подумает, что замок свободен, и также начнет работу с ресурсом. Если в этот момент управление вернется первому потоку, он продолжится с того же места, то есть уже после проверки условия, по ветке "then". То есть тоже начнет работу с ресурсом.

Замки, которые существуют в библиотеках для многопоточного программирования реализованы специальным образом на низком уровне так, что проверка условия и изменение состояния замка - это одна атомарная операция. Так что даже если поток переключится, мы либо войдем в замок, либо нет. Поэтому одновременной работы с ресурсом не происходит.

Замок помогает заблокировать доступ к ресурсу. А что делать, если потоки в программе используют несколько общих ресурсов? Нужно создать по одному замку на каждый общий ресурс. Будь то переменные, сетевые сокеты, вывод в терминал или файлы - вы должны отследить все общие ресурсы - все "места пересечения" потоков вашей программы и работу с каждым ресурсом закрыть замком. Конечно, чем сложнее программа, чем с большим количеством объектов работают потоки, тем сложнее все отследить.

Именно поэтому, кстати, в Python существует так называемая глобальная блокировка интерпретатора. Разработчики языка в какой-то момент решили, что ставить отдельный замок на каждую блокирующую операцию - это слишком сложно и чревато ошибками. И поэтому поставили общую блокировку - одновременно только один поток может выполняться на интерпретаторе. Из-за этого многие считают реализацию многопоточности в Python неполноценной.
{: .notice--warning}

Но если вы работаете с несколькими ресурсами в многопоточной программе, вас поджидает еще одна потенциальная проблема - дедлоки, или взаимоблокировка. Давайте представим, что у нас есть два потока, каждый из которых работает с двумя ресурсами - А и В. Первый поток получает доступ к ресурсу А (закрывает соответствующий замок), и начинает с ним работать. Не освобождая А, он еще хочет получить доступ к ресурсу В. Тут допустим, что в это время второй поток уже получил доступ к ресурсу В (закрыл замок ресурса В) и хочет получить доступ к А. Получается неразрешимая ситуация.

![Deadlock](http://pro-java.ru/wp-content/uploads/2017/10/vzaimnaya-blokirovka-v-java-pro-java-ru.jpg "Deadlock"){: .align-center style="width: 600px;"}
Источник: [Pro-Java](https://pro-java.ru/parallelizm-v-java/vzaimnaya-blokirovka-v-java/).
{: style="text-align: center; font-size:0.7em;"}

Первый поток не может продолжится и блокируется потому, что он ждет, когда второй поток освободит ресурс В, а второй поток тоже заблокирован и ждет, когда первый поток освободит ресурс А. Так что ни один поток не может продолжать выполняться. И по сути вся программа намертво блокируется. Выхода их дедлока нет, можно только прервать задачу.

Но избежать такой ситуации при написании многопоточной программы довольно просто. Нужно всего лишь договориться, всегда блокировать ресурсы в строго определенном порядке. Причем это нужно только тогда, когда поток хочет одновременно поработать с двумя и более ресурсами. Хочешь работать в ресурсом А - пожалуйста. Нужен один ресурс В - тоже никаких ограничений. А вот если нужно и то и другое сразу - то всегда блокируем сначала ресурс А, а потом - В. И никогда не наоборот. Тогда дедлок никогда не сможет случиться.

Замки - это самый простой способ блокировки ресурсов. В более сложных случая могут понадобиться более продвинутые способы. Например, более сложной версией замка является семафор - замок со встроенным счетчиком подключений. Он позволяет ограничить количество одновременно работающих с ресурсом потоков. Такое полезно, например, для ограничения нагрузки на какие-либо участки программы. Например, для ограничения количества одновременных подключений к серверу или базе данных.

В заключении надо сказать, что даже самые простые замки сильно помогают обеспечить потокобезопасность программы. Но в замками не следует перебарщивать. Нужно помнить, что ожидание замка - это блокирующая операция, а смысл многопоточности - оптимизация блокировок. Может показаться соблазнительным не разбираться сильно и закрыть замком большую часть многопоточного алгоритма. Но это значит, что он сможет выполняться только в одном потоке за раз. Другими словами, если закрыть замком весь поток, то исчезнет смысл вообще использовать потоки - программа будет выполняться в синхронном режиме, как обычно. Да, он будет полностью потокобезопасно, что что толку? Поэтому замками надо закрывать минимально, только самые критические участки алгоритма программы, в которых идет именно работа с общим ресурсом.

{% capture notice-2 %}
Выводы:
1. В операционных системах существуют специальные объекты - замки.
2. Замок можно получить или освободить - это атомарные операции, они не могут быть прерваны.
3. При попытке получить заблокированный замок поток блокируется - ждет его освобождения.
4. При доступе к замку он блокируется, чтобы другой поток не мог в это время работать с ресурсом.
5. На каждый ресурс нужно использовать один замок.
6. Есть опасность попасть в дедлок - ресурсы нужно блокировать в определенном порядке.
7. Существуют более продвинутые способы блокировки - семафоры и мьютексы.
8. Чем больше блокировок использовать, тем меньше толку от многопоточности.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


## Многозадачное программирование на Python


### Какие основные инструменты параллельного программирования?


|   | Процессы | Потоки | Async |
|:--|:--:|:---:|:---:|
| Оптимизация блокировок | вытесняющая | вытесняющая | кооперативная |
| Использование нескольких ядер | да | нет | нет |
| Масштабируемость | низкая (десятки) | средняя (сотни) | высокая (тысячи+) |
| Использование стандартных блокирующих операций | да | да | нет |
| GIL | нет | да | нет |

В языках программирования существуют специальные механизмы реализации как параллельного, так и асинхронного программирования.

{% capture notice-2 %}
Выводы:
1. Почти все языки программирования позволяют создавать процессы.
2. Почти у всех языков программирования есть средства многопоточного программирования.
3. В питоне три стандартные библиотеки дают возможность параллельного программирования.
4. Модуль multiprocessing позволяет писать многопроцессные программы.
5. Модуль threading позволяет писать многопоточные программы.
6. Модуль asyncio позволяет создавать асинхронные задачи с кооперативным переключением.
7. У каждого подхода свои недостатки и своя ниша.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Как выделить функцию в поток?

```py
import threading 
def proc():
    print("Процесс")
 
p1 = threading.Thread(target=proc, name="t1")
p2 = threading.Thread(target=proc, name="t2")
p1.start()
p2.start()
```

{% capture notice-2 %}
Выводы:
1. Для создания потока нужен обособленный участок кода - проще всего использовать функцию.
2. Создание и запуск потока - разные операции, они не обязательно идут последовательно.
3. При запуске потока программа “раздваивается” - появляются новый и основной поток.
4. Основной поток  продолжает выполняться и после запуска нового.
5. В каком порядке будут выполнены инструкции - зависит от множества факторов.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Как передать параметры в поток?

```py
import threading
 
def proc(n):
    print "Процесс", n
 
p1 = threading.Thread(target=proc, name="t1", kwargs={"n": "1"})
p2 = threading.Thread(target=proc, name="t2", args=[2])
p1.start()
p2.start()
```

{% capture notice-2 %}
Выводы:
1. Для дифференциации потоков в функцию-поток можно передать параметр.
2. Это очень удобно для распараллеливания параметрических действий.
3. Обратите внимание, что вернуть значение их потока не так просто.
4. Для получения результата работы потока используется консоль, общие переменные или файлы.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Как выделить класс в поток?

```py
import threading 
 
class T(threading.Thread):
  def __init__(self, n):
    threading.Thread.__init__(self, name="t" + n)
    self.n = n
  def run(self):
    print "Процесс", self.n
 
p1 = T("1")
p2 = T("2")
p1.start()
p2.start()
```

1. Часто функции недостаточно и в потоке можно запустить класс.
2. При этом выполняться будет именно метод run().
3. Это требуется, если в функцию придется передавать очень много значений и удобнее хранить их в полях класса.

### Как завершить выполнение потока?

1. Часто требуется совершить какие-либо действия после окончания работы потока.
2. Для этого существует операция присоединения потока.
3. Текущий поток блокируется и ждет, когда будет закончен заданный.
4. Это часто требуется, если нужно воспользоваться результатом работы потока.
5. Надо четко понимать, что кого будет ждать, в потоках легко запутаться.
6. Поток, в котором выполняется присоединение будет ждать тот поток, у которого оно вызвано.
7. Чаще всего дочерние потоки присоединяются к главному.
8. Частый шаблон - массовое создание и затем массовое присоединение потока.

### Как использовать multiprocessing?

1. Модуль multiprocessing был добавлен в Python версии 2.6. 
2. Используя multiprocessing вы можете обойти GIL.
3. Входит в стандартную библиотеку Python
4. Позволяет запускать задачи в разных процессах
5. Процессы управляются операционной системой
6. Каждый процесс имеет свою копию интерпретатора и всех ресурсов
7. Позволяет получить прирост производительности на многоядерных системах

### Как выделить функцию в процесс?

```py
import os
from multiprocessing import Process 
 
def doubler(number):
    result = number * 2
    proc = os.getpid()
    print('{0} doubled to {1} by process id: {2}'.format(
        number, result, proc)) 
 
if __name__ == '__main__':
    numbers = [5, 10, 15, 20, 25]
    procs = []
    
    for index, number in enumerate(numbers):
        proc = Process(target=doubler, args=(number,))
        procs.append(proc)
        proc.start()
    
    for proc in procs:
        proc.join()
```

1. Синтаксис аналогичен созданию потока. По внутреннему устройству они сильно различаются.
2. Процессы управляются операционной системой, не интерпретатором.
3. В каждый процесс загружается собственная копия интерпретатора и всех переменных.
4. Поэтому глобальных переменных не будет - у каждого потока свой стек.
5. Процессы питона - очень тяжеловесные, ведь у каждого свой интерпретатор.
6. Только процессы можно использовать для параллелизма на несколько ядер.
7. Вернуть значение из процесса еще сложнее, ведь они изолированные.
8. Довольно частый шаблон - использование пула потоков и функции map.

### Как использовать Asyncio?

Компоненты Asyncio подразделяются на API-интерфейсы высокого уровня (для написания программ) и API-интерфейсы низкого уровня (для написания библиотек или сред на основе asyncio).

Каждая программа asyncio может быть написана с использованием только высокоуровневых API. Если вы не пишете фреймворк или библиотеку, вам никогда не нужно трогать API низкого уровня.

С учетом вышесказанного давайте рассмотрим основные высокоуровневые API и обсудим основные концепции.

В общем, coroutine (сокращение от cooperative subroutine) – это подпрограмма, предназначенная для добровольной упреждающей многозадачности: она активно уступает свои ресурсы другим подпрограммам и процессам, а не принудительно вытесняется ядром. Термин «coroutine» был придуман в 1958 году Мелвином Конвеем (в Conway’s Law), чтобы описать код, который сам освобождает свои ресурсы для других частей системы.

1. Асинхронные корутины управляются специальной библиотекой - asyncio.
2. Это самый рекомендуемый способ реализовать асинхронное программирование на питоне.
3. Сначала надо создать цикл событий, затем загрузить в него одну или несколько задач.
4. Кооперативная многозадачность - вы сами отмечаете места, где может переключиться контекст.
5. Большой минус - надо использовать особые реализации всех блокирующих операций.

### Как создать асинхронный сервер?