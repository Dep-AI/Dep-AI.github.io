---
title: "Многозадачное программирование"
section: os
---


### Что такое блокировка потока?

![alt_text](images/image1.png "image_tooltip"){: .align-center style="width: 80%;"}

Любая компьютерная программа - это последовательность инструкций, выполняемая на центральном процессоре. Инструкции идут одна за одной и выполняются последовательно на конвейере. Однако, довольно часто при работе программ центральному процессору приходится обращаться к внешним устройствам - оперативной памяти, жесткому диску, устройствам ввода-вывода. Все они работают очень медленно с точки зрения процессора. 

Более того, выполнение таких операций может потребовать неопределенно долгого времени. Например, если в программе встречается инструкция чтения с клавиатуры, программа должна ждать ввода пользователя. Причем, она не может продолжиться до тех пор, пока эта инструкция не будет выполнена и не будет возвращено значение. Ведь инструкции в программе идут последовательно и выполнение следующей инструкции может зависеть от результата предыдущей. Такая ситуация называется блокировкой потока. То есть, остановка потока выполнения инструкций программы.

В операционных системах для этого существует специальный механизм - системные вызовы. Как мы знаем, программа не может напрямую обращаться к внешним устройствам, она должна вызвать соответствующую функцию операционной системы. В такой момент управление переходит к ней и программа должна ожидать окончания выполнения системного вызова. 

Таким образом, при выполнении некоторых действий выполнение программы блокируется. То есть она будет ждать какое-то, заранее неопределенное время. Такие операции называются блокирующими. Примерами блокирующих операций являются:

* обращение к внешним устройствам через механизм системных вызовов;
* файловый и консольный ввод-вывод;
* выполнение сетевых запросов;
* явные инструкции ожидания (например, time.sleep в питоне);

Неблокирующими операциями являются инструкции, которые сразу же выполняются на центральном процессоре. К ним относятся математические операции, операции со строками, массивами, и другие простые манипуляции. Во время выполнения таких инструкций программа полностью загружает центральный процессор (или как минимум, одно его ядро). 

На практике, большинство прикладных программ большую часть времени своего выполнения находятся именно в таком состоянии ожидания. Это приводит к нерациональному расходованию ресурсов. И именно для решения этой проблемы в операционных системах был придуман механизм многозадачности. Операционная система сама отслеживает состояние процессов и может переключить выполнение на другой, незаблокированный процесс пока этот ждет наступления внешнего события.

Выводы:
1. Программы в своей работе часто обращаются к медленным внешним устройствам.
2. Блокирующими называются операции, которые требуют неопределенного времени.
3. Классический пример - операция чтения с консоли.
4. При выполнении блокирующей операции выполнение программы приостанавливается.
5. Выполнение не может быть продолжено до наступления какого-то внешнего события.
6. Управление передается операционной системе посредством системного вызова.
7. Большинство программ большую часть времени просто ждут.


### Откуда берется прирост скорости?

В зависимости от того, насколько часто та или иная программа (а точнее ее алгоритм) выполняет блокирующие операции, все алгоритмы можно разделить на две условные категории:

![alt_text](images/image2.png "image_tooltip")

* задачи, ограниченные процессором (cpu-bound tasks) - это программы, большую часть которых составляют вычислительные инструкции. Такие программы редко блокируются и сильно нагружают центральный процессор. Скорость их выполнения напрямую зависит от скорости работы процессора.
* задачи, ограниченные вводом-выводом (io-bound tasks) - это такие программы, которые часто выполняют блокирующие операции, чаще всего - операции ввода-вывода. Такие программы наоборот, большую часть времени находятся в ожидании, и скорость их выполнения зависит от внешних факторов.

Надо подчеркнуть, что это характеристика самой задачи, то есть алгоритма, а не способа его решения. Если задача связана с вводом-выводом, ее нельзя сделать чисто вычислительной, и наоборот. Хотя, конечно, можно немного уменьшить или увеличить количество блокирующих операций, специальным образом спроектировав алгоритм, но в целом, именно сама решаемая задача будет определять, к какому из этих классов будет относиться программа.

Еще заметим, что данное деление, конечно, условное, и нет четкой границы между этими двумя классами. Это скорее непрерывный спектр, а эти классы - его полюса. Мы описываем его только потому, что разработчику программ полезно понимать, где в этом спектре находится его программа, так как от этого зависит, как ее выполнение можно ускорить. Ведь подходы к оптимизации таких программ существенно различаются.

Выполнение задач, ограниченных процессором, можно ускорить двумя способами. Во-первых, можно увеличить скорость процессора. Это очевидный, но не всегда возможный вариант. Во-вторых, некоторые такие задачи можно разделить на относительно независимые блоки, подзадачи, некоторые из которых можно выполнять одновременно. Такое возможно, если выполнение одного блока никак не использует результат выполнения других блоков. В таком случае, их можно выполнять одновременно, например, на разных ядрах одного процессора (или на разных процессорах, или даже машинах в кластере) и за счет этого получить прирост скорости. Такой подход называется параллелизмом или параллельным программированием.

Задачи, ограниченные вводом-выводом, сложно ускорить, используя более быстрый процессор. Это, конечно, не повредит, но такие алгоритмы только малую долю времени выполняются на нем. Здесь опять же поможет разбиение программы на независимые подзадачи. Но их уже не обязательно выполнять одновременно. Можно переключать подзадачи по мере блокировок, примерно так же как поступает операционная система с процессами. Такой подход называется асинхронное программирование. Еще вы можете встретить термин “оптимизация блокировок”.

![alt_text](images/image3.png "image_tooltip")

Выполнение программы в таком случае, перестает быть строго последовательным. То есть мы не можем быть уверены в том, что инструкции программы выполнятся именно в той последовательности, которую мы задали при написании программы. Это немного похоже на создание программ в процедурном стиле, когда вместо написания всех инструкций в линейной последовательности, вы создаете обособленные функции, а их основного кода можете вызывать их в произвольном порядке.

![alt_text](images/image4.png "image_tooltip")

Еще это похоже на сеанс одновременной игры в шахматы. Гроссмейстер в этой аналогии - как процессор. Он думает быстро и его время очень ценно. А игроки - это задачи, которые часто “блокируют” его, то есть долго думают над ходом. Если бы гроссмейстер играл с каждым игроком последовательно, весь сеанс занял бы очень много времени. Поэтому на практике он не ждет окончания хода игрока, а перемещается к следующему и так далее по кругу. За исключением технических деталей, именно так и работают асинхронные программы.

Надо сказать, что в информатике существует путаница в терминах, связанных с этой темой. Не все четко понимают разницу между асинхронным и параллельным программированием. Тем более, что подзадачи тоже могут выполняться на разных ядрах. Поэтому не удивляйтесь, если в других источниках увидите другие определения асинхронности и параллелизма. Но здесь я буду использовать эти два термина для обозначения двух разных подходов к ускорению работы программ. Для общего названия практики программирования, заключающейся в разбиении алгоритма на независимые подзадачи я выбрал термин “конкуррентное программирование”. Это не от слова конкуренция, а от английского concurrency - одновременность. Конкуррентное программирование, таким образом, включает в себя и асинхронность и параллелизм.

Выводы:
1. Все алгоритмы можно поделить на две условные категории.
2. Задачи, ограниченные процессором - вычислительные, постоянно выполняются.
3. Задачи, ограниченные вводом-выводом - часто ждут внешних событий
4. Первую категорию можно ускорить только за счет параллелизма.
5. Вторую - за счет асинхронности и, в меньшей степени, за счет параллелизма.
6. В момент, когда одна задача блокируется, процессор может переключиться на другую.
7. Асинхронное программирование очень похоже на сеанс одновременной игры.
8. В терминах существует путаница. Особенно в русскоязычных.


### Каковы основные недостатки конкуррентного программирования?

Конкуррентное программирование помогает решить насущную проблему - оптимизацию работы программ. И поэтому оно широко используется при создании сложных информационных продуктов. В первую очередь в этом подходе нуждаются сетевые приложения, так как обмен данными по сети - это блокирующие операции. Тем не менее, надо понимать, что применение конкуррентного программирования порождает определенные сложности. 

Мы уже упоминали, что некоторые задачи по самой своей природе являются последовательными. Если выполнение каждой следующей инструкции требует использование результата предыдущей, то мы никак не сможет разделить программу на независимые подзадачи. Это, конечно, редкий случай, но такое может случиться. Большинство задач, все же поддаются некоторой декомпозиции.

Приведем простой пример - алгоритм решения квадратного уравнения через дискриминант. Можно разделить эту задачу на три - вычисление дискриминанта, вычисление первого корня и вычисление второго. Причем, первый этап должен быть реализован в самом начале, так как его результат используется в последующих шагах. А вот вычисления корней являются независимыми задачами, и их можно выполнять в любой последовательности и одновременно. Это, конечно, вычислительно очень простая задача, но хорошо иллюстрирует пример частично распараллеливаемого алгоритма. 

Конкуррентное программирование тесно связано с реализацией механизма многозадачности. Такой механизм может реализовываться либо самой операционной системой через механизм процессов, либо библиотекой языка программирования. Многозадачность - это механизм псевдоодновременного выполнения нескольких задач (алгоритмов) на компьютере, когда система многозадачности периодически переключает выполнение одного потока команд на другой. Это называется переключение контекста. В любом случае нужно помнить о двух типах многозадачности - кооперативной и вытесняющей. при кооперативной многозадачности переключение на другую задачу происходит при блокировке текущей. При вытесняющей - система сама может переключить контекст в произвольный момент, между двумя любыми инструкциями.

Если ваши задачи являются полностью изолированными, каждая задача “не замечает” переключение контекста, ведь при возврате к выполнению этой задачи она продолжится с того же места без каких-либо побочных эффектов. Проблемы возникают, если задачи взаимосвязаны и используют какие-либо общие ресурсы. Например, общие переменные. Ведь пока задача была приостановлена, значение этой общей переменной могло поменяться, а текущая задача на это не рассчитывала. А на практике большинство конкуррентных задач так или иначе используют общие ресурсы - переменные (то есть общие области в памяти), файлы, внешние устройства, сеть. 

Поэтому если какой-то алгоритм работает корректно в обычном, однопоточном режиме, он может работать некорректно в конкуррентном виде именно из-за таких общих ресурсов. Это называется потоконебезопасные алгоритмы. При написании конкуррентных программ нам нужно следить за тем, как задачи в них взаимодействуют и обеспечивать потокобезопасность. Это дополнительные сложности, с которыми мы сталкиваемся при проектировании и реализации конкуррентных программ.

Еще одна большая сложность при реализации конкуррентных программ - сложность их отладки. Особенно при использовании вытесняющей многозадачности программист не может предсказать моменты переключения контекста. В результате инструкции выполняются в случайном порядке, что может приводить к ошибкам, которые то появляются, то исчезают. Ловить и исправлять такие ошибки довольно сложно.

Вместе с этим надо сказать, что распараллеливание алгоритма не является панацеей для быстродействия. Ведь переключение контекста - это сам по себе довольно длительный процесс. Конечно, обычно не приходится реализовывать собственный механизм многозадачности - есть уже готовые инструменты, но все равно, на создание задач и переключение между ними тратится время и ресурсы. Существует даже понятие чрезмерного распараллеливания, когда большая часть времени выполнения программы тратится не на выполнение полезной задачи, а на переключение между задачами.

Поэтому прирост скорости при использовании конкуррентности никогда не бывает кратным. Даже если вы разбили программу на пять задач и запустили одновременно на разных ядрах процессора, не ожидайте пятикратного ускорения программы. Насколько в реальности может быть ускорена программа зависит от множества факторов, все, что мы можем сказать, что ускорение будет меньше, чем в пять раз.

Несмотря на все сложности, параллельное и асинхронное программирование - очень распространенные техники, которые зачастую помогают решить насущные проблемы разработки сетевых приложений. Часть только с помощью распараллеливания можно реализовать некоторую функциональность, которая в чисто последовательном режиме была бы просто невозможной. Например, создание сервера, который может одновременно обслуживать нескольких клиентов. Так что знание основ конкуррентного программирования - необходимый навык для любого разработчика.

Выводы:
1. Некоторые задачи являются в принципе последовательными.
2. Такие программы сложнее проектировать, реализовывать и отлаживать.
3. Существует понятие потокобезопасности, которую надо обеспечивать.
4. Одновременное программирование связано с механизмами многозадачности.
5. Вытесняющая многозадачность означает непредсказуемое переключение контекста.
6. Не стоит забывать про накладные расходы - это все не бесплатно.
7. Прирост скорости даже в идеальном случае не будет кратным.


### Чем отличаются процессы и потоки?

![alt_text](images/image5.png "image_tooltip")

Для обеспечения многозадачности существуют известные механизмы операционной системы - процессы. Вы можете спроектировать программу так, чтобы она состояла из нескольких взаимодействующих процессов. Тогда запуском, переключением и управлением процессами займется операционная система. Здесь надо помнить два факта. Во-первых, каждый процесс является изолированным участком памяти, который имеет свой стек, собственные структуры данных, исполняемый код, и множество скрытых атрибутов. Во-вторых, все современные операционные системы реализую именно вытесняющую многозадачность. То есть процессы могут быть приостановлены и переключены в произвольные моменты времени, вы как разработчик никак на это не можете повлиять.

Выводы:
1. Для обеспечения многозадачности в операционной системе используются процессы.
2. Потоки выполняются в рамках одного процесса и имеют общую память.
3. Потоки сейчас не поддерживаются на уровне ядра никакими популярными ОС.
4. Создание процесса - довольно длительная процедура.
5. Процессы управляются операционной системой, у программиста не контроля.
6. Операции с процессами происходят через системные вызовы и не зависят от языка.


### Что может пойти не так?

1. Проблемы возникают, когда подзадачи обращаются к общим ресурсам. 
2. Если у потоков есть общая переменная, она может измениться без ведома потока.
3. Если несколько потоков пишут данные в один файл, вывод может быть перепутан.
4. То же самое может произойти с выводом в консоль.
5. Потокобезопасность - это свойство программы работать правильно в конкуррентном режиме.
6. Программист должен обеспечить потокобезопасность своей программы.
7. Самый понятный способ обеспечения потокобезопасности - ввести блокировки ресурсов.


### Как заблокировать доступ к ресурсу?

1. В операционных системах существуют специальные объекты - замки.
2. Замок можно получить или освободить - это атомарные операции, они не могут быть прерваны.
3. При попытке получить заблокированный замок поток блокируется - ждет его освобождения.
4. При доступе к замку он блокируется, чтобы другой поток не мог в это время работать с ресурсом.
5. На каждый ресурс нужно использовать один замок.
6. Есть опасность попасть в дедлок - ресурсы нужно блокировать в определенном порядке.
7. Существуют более продвинутые способы блокировки - семафоры и мьютексы.


## Конкуррентное программирование на Python


### Какие основные инструменты параллельного программирования?


|   | Процессы | Потоки | Async |
|:--|:--:|:---:|:---:|
| Оптимизация блокировок | вытесняющая | вытесняющая | кооперативная |
| Использование нескольких ядер | да | нет | нет |
| Масштабируемость | низкая (десятки) | средняя (сотни) | высокая (тысячи+) |
| Использование стандартных блокирующих операций | да | да | нет |
| GIL | нет | да | нет |

В языках программирования существуют специальные механизмы реализации как параллельного, так и асинхронного программирования.

1. Почти все языки программирования позволяют создавать процессы.
2. Почти у всех языков программирования есть средства многопоточного программирования.
3. В питоне три стандартные библиотеки дают возможность параллельного программирования.
4. Модуль multiprocessing позволяет писать многопроцессные программы.
5. Модуль threading позволяет писать многопоточные программы.
6. Модуль asyncio позволяет создавать асинхронные задачи с кооперативным переключением.
7. У каждого подхода свои недостатки и своя ниша.

### Как выделить функцию в поток?

```py
import threading 
def proc():
    print("Процесс")
 
p1 = threading.Thread(target=proc, name="t1")
p2 = threading.Thread(target=proc, name="t2")
p1.start()
p2.start()
```

1. Для создания потока нужен обособленный участок кода - проще всего использовать функцию.
2. Создание и запуск потока - разные операции, они не обязательно идут последовательно.
3. При запуске потока программа “раздваивается” - появляются новый и основной поток.
4. Основной поток  продолжает выполняться и после запуска нового.
5. В каком порядке будут выполнены инструкции - зависит от множества факторов.

### Как передать параметры в поток?

```py
import threading
 
def proc(n):
    print "Процесс", n
 
p1 = threading.Thread(target=proc, name="t1", kwargs={"n": "1"})
p2 = threading.Thread(target=proc, name="t2", args=[2])
p1.start()
p2.start()
```

1. Для дифференциации потоков в функцию-поток можно передать параметр.
2. Это очень удобно для распараллеливания параметрических действий.
3. Обратите внимание, что вернуть значение их потока не так просто.
4. Для получения результата работы потока используется консоль, общие переменные или файлы.

### Как выделить класс в поток?

```py
import threading 
 
class T(threading.Thread):
  def __init__(self, n):
    threading.Thread.__init__(self, name="t" + n)
    self.n = n
  def run(self):
    print "Процесс", self.n
 
p1 = T("1")
p2 = T("2")
p1.start()
p2.start()
```

1. Часто функции недостаточно и в потоке можно запустить класс.
2. При этом выполняться будет именно метод run().
3. Это требуется, если в функцию придется передавать очень много значений и удобнее хранить их в полях класса.

### Как завершить выполнение потока?

1. Часто требуется совершить какие-либо действия после окончания работы потока.
2. Для этого существует операция присоединения потока.
3. Текущий поток блокируется и ждет, когда будет закончен заданный.
4. Это часто требуется, если нужно воспользоваться результатом работы потока.
5. Надо четко понимать, что кого будет ждать, в потоках легко запутаться.
6. Поток, в котором выполняется присоединение будет ждать тот поток, у которого оно вызвано.
7. Чаще всего дочерние потоки присоединяются к главному.
8. Частый шаблон - массовое создание и затем массовое присоединение потока.

### Как использовать multiprocessing?

1. Модуль multiprocessing был добавлен в Python версии 2.6. 
2. Используя multiprocessing вы можете обойти GIL.
3. Входит в стандартную библиотеку Python
4. Позволяет запускать задачи в разных процессах
5. Процессы управляются операционной системой
6. Каждый процесс имеет свою копию интерпретатора и всех ресурсов
7. Позволяет получить прирост производительности на многоядерных системах

### Как выделить функцию в процесс?

```py
import os
from multiprocessing import Process 
 
def doubler(number):
    result = number * 2
    proc = os.getpid()
    print('{0} doubled to {1} by process id: {2}'.format(
        number, result, proc)) 
 
if __name__ == '__main__':
    numbers = [5, 10, 15, 20, 25]
    procs = []
    
    for index, number in enumerate(numbers):
        proc = Process(target=doubler, args=(number,))
        procs.append(proc)
        proc.start()
    
    for proc in procs:
        proc.join()
```

1. Синтаксис аналогичен созданию потока. По внутреннему устройству они сильно различаются.
2. Процессы управляются операционной системой, не интерпретатором.
3. В каждый процесс загружается собственная копия интерпретатора и всех переменных.
4. Поэтому глобальных переменных не будет - у каждого потока свой стек.
5. Процессы питона - очень тяжеловесные, ведь у каждого свой интерпретатор.
6. Только процессы можно использовать для параллелизма на несколько ядер.
7. Вернуть значение из процесса еще сложнее, ведь они изолированные.
8. Довольно частый шаблон - использование пула потоков и функции map.

### Как использовать Asyncio?

Компоненты Asyncio подразделяются на API-интерфейсы высокого уровня (для написания программ) и API-интерфейсы низкого уровня (для написания библиотек или сред на основе asyncio).

Каждая программа asyncio может быть написана с использованием только высокоуровневых API. Если вы не пишете фреймворк или библиотеку, вам никогда не нужно трогать API низкого уровня.

С учетом вышесказанного давайте рассмотрим основные высокоуровневые API и обсудим основные концепции.

В общем, coroutine (сокращение от cooperative subroutine) – это подпрограмма, предназначенная для добровольной упреждающей многозадачности: она активно уступает свои ресурсы другим подпрограммам и процессам, а не принудительно вытесняется ядром. Термин «coroutine» был придуман в 1958 году Мелвином Конвеем (в Conway’s Law), чтобы описать код, который сам освобождает свои ресурсы для других частей системы.

1. Асинхронные корутины управляются специальной библиотекой - asyncio.
2. Это самый рекомендуемый способ реализовать асинхронное программирование на питоне.
3. Сначала надо создать цикл событий, затем загрузить в него одну или несколько задач.
4. Кооперативная многозадачность - вы сами отмечаете места, где может переключиться контекст.
5. Большой минус - надо использовать особые реализации всех блокирующих операций.