---
title: "Основы сетевого программирования"
# section: os
---



### Основные понятия сетевого программирования


#### Чем сетевые приложения отличаются от обычных?



![alt_text](/assets/images/np_text/np10-1.png "image_tooltip"){: .align-center style="width: 50%;"}


**Сетевыми приложениями мы будем называть любые приложения, которые обмениваются данными, используя компьютерную сеть.** Это довольно широкое определение, и, конечно, мы не сможем рассмотреть все многообразие обширного мира сетевых технологий, который, вдобавок развивается очень быстро и новые технологии, приемы и методики появляются чуть ли не каждый день. Поэтому в данном пособии мы сконцентрируемся на освоении базовых схем обмена информацией по сети, которые лежат в основе всех более продвинутых вещей. Используя полученные знания вы сами сможете строить все более и более сложные схемы взаимодействия разных приложений и разных компонентов одного приложения по сети.

Сетевые приложения могут обмениваться информацией с другими, сторонними приложениями либо строить взаимодействие по сети между компонентами одного и того же приложения, написанного одним автором или одной командой. 



Возможность обмениваться данными по сети открывает перед разработчиком широкий круг возможностей.

**Вы можете обращаться к сторонним сервисам, имеющим открытое API.** Сегодня существует множество сервисов, постоянно действующих в сети и предоставляющих способ обмена данными в автоматизированном формате через специальную схему взаимодействия, то есть публичный интерфейс, или API. Например, ваша программа может обратиться к погодному сервису и получить данные о погоде в определенном месте или городе. 

**Также вы можете сами разработать такой публичный сервис.** Если ваше приложение может выдавать информацию по запросу неограниченному кругу лиц, вы можете опубликовать в Интернете приложение, которое будет обрабатывать входящие соединения и отвечать на запросы. Нужно только спроектировать API вашего сервиса, реализовать и задокументировать его.

**Можно строить распределенные приложения**. Сейчас довольно распространены приложения, основой функционирования которых является взаимодействие множества компонентов, запущенных на совершенно независимых компьютерах сети. Так работают, например, пиринговые сети, системы распределенных вычислений или ботнеты.

**Добавьте к любой вашей программе возможность самостоятельно обновляться по сети.** Почти все программы имеют подсистему автоматической и регулярной проверки сервера разработчика программы на предмет выхода новой версии. При наличии такой можно предложить пользователю скачать ее, либо обновиться самостоятельно.

**Можно использовать централизованную схему клиент-сервер.** В таком случае ваша программа может быть разделена на две логические части - клиентскую, которая запускается на компьютере пользователя и предоставляет ему интерфейс, и серверную, которая работает на сервере, принадлежащем разработчику, и может заниматься, например, доступом к базе данных. Логика работы программы тоже может быть разделена на две части.

**Можно организовывать централизованное хранилище данных.** Это удобно, если, например,  вам нужно собирать данные от пользователей вашей программы в одном месте, либо предоставить пользователям возможность обмениваться сообщениями. 

Если вы организуете взаимодействие с клиентами посредством нескольких каналов, можно позаботиться об **омниканальности** - возможности сохранять информацию о всех взаимодействиях с пользователем по любым каналам, создавая ощущение бесшовности. Такую схему активно используют, например, банки. Вы можете зайти в мобильное приложение, совершить там какую-то операцию, а затем зайти в личный кабинет на веб-сайте банка и продолжить работу с того же места.

{% capture notice-2 %}
Выводы:
1. Сетевые приложения - это программы, которые обмениваются данными через сеть.
1. В подавляющем большинстве случаев обмен идет на основе протоколов TCP/IP.
1. В настоящее время все более или менее развитые приложения являются сетевыми в той или иной мере.
1. Приложения обмениваются данными с другими либо между своими компонентами.
1. Можно обращаться к сторонним сервисам
2. Создание публичного сервиса - это тоже задача сетевого программирования.
3. Многопользовательские приложения очень распространены в определенных предметных областях.
4. Автоматические обновления - это возможность, которая есть почти во всех программных продуктах.
5. Одна из частных задач сетевого программирования - удаленное хранение данных
6. Для экономики и бизнеса важна омниканальность взаимодействия с клиентами и пользователями.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


#### В чем сложности создания сетевых приложений?

Разработка сетевых приложений - отдельная дисциплина информатики, требующая от программиста некоторых дополнительных знаний и умений. Естественно, для создания приложений, использующих возможности компьютерной сети необходимо знать основы функционирования таких сетей, понимать главные сетевые протоколы, понятие маршрутизации и адресации. В подавляющем большинстве случаев на практике используются протоколы семейства TCP/IP. Это сейчас универсальный механизм передачи данных. Но сами сетевые приложения могут интенсивно использовать разные конкретные протоколы, находящиеся на разных уровнях модели OSI.

Например, в этой теме мы в основном будем говорить об использовании TCP и UDP сокетов, то есть будем работать на транспортном уровне модели OSI. Но можно работать и на других уровнях с использованием других протоколов. Так веб приложения наиболее активно полагаются на протокол HTTP и его защищенную модификацию - HTTPS. Поэтому так важно знать все многообразие существующих схем и протоколов обмена данными. Ведь при проектировании приложения нужно выбрать тот протокол, уровень, который наилучшим образом подходит для решений стоящей перед разработчиками прикладной задачи.

Кроме того, при проектировании и реализации сетевых приложений на вас, как на разработчике лежит задача продумывания конкретного обмена данными. Используемый протокол регламентирует порядок передачи данных, но конкретную схему, последовательность обмена создает разработчик конкретного приложения. Вам надо определиться, какие данные будут передаваться по сети, в каком формате, в каком порядке. Будете ли вы использовать, например, JSON или XML, может, стоит придумать свой формат данных? После соединения, какой модуль начинает передачу, сколько итераций передачи будет проходить за одно соединение, как обозначить конец передачи, нужно ли регламентировать объем передаваемой информации, нужно ли использовать шифрование данных - это все примеры вопросов, которые необходимо будет решить в ходе разработки. Фактически, каждое сетевое приложение - это по сути еще один, очень конкретный протокол передачи, которые для себя придумывают разработчики специально для этого приложения. 

Еще одна область, непосредственно связанная с сетевым обменом - это параллельное программирование. Сетевые приложения обычно очень активно используют многопоточности или другие средства обеспечения многозадачности. Какие-то операции должны выполняться в фоне, пока выполняются другие. Такое приложение становится гораздо более сложным по своей структуре. И необходимо отдельно заботиться о том, чтобы оно работало корректно при всех возможных условиях. Это происходит за счет обеспечения потокобезопасности, использования правильных архитектурных и дизайнерских шаблонов, специальных алгоритмов и структур данных.

Отдельный вопрос, непосредственно связанный с сетевым программированием - обеспечение безопасности и конфиденциальности обмена данными. Любое приложение, принимающее данные по сети должно быть рассчитано на то, что его может вызвать и передать данные любое приложение или пользователь. В том числе, с неизвестными или деструктивными целями. Поэтому в сетевых приложениях необходимо применять проверки входных данных, валидацию всей принимаемой информации, возможно - механизмы аутентификации пользователей. Если же ваше приложение отправляет данные - здесь тоже возможны риски того, что они попадут не по назначению. Так можно применять те же механизмы аутентификации, шифрования трафика. Особенно аккуратным надо быть, если ваше приложение собирает, хранит или передает персональные данные пользователей. В этом случае могут применяться определенные юридические нормы и обязательства, которые разработчики обязаны соблюдать.

Надо помнить, что сетевые приложения используют не только протоколы и соглашения передачи данных, но и конкретную физическую сетевую инфраструктуру. И у нее есть определенные параметры, которые необходимо учитывать - полоса пропускания, надежность, доступность. Как будет работать приложение, если в какой-то момент перестанет быть доступна сеть? Какая скорость передачи данных нужна для бесперебойной работы серверной части приложения? На сколько одновременных подключений рассчитан каждый программный модуль? За этим всем нужно следить не только на этапе проектирования, принятия решений, но и в процессе работы приложения - организовывать постоянный мониторинг, продумывать вопросы управления нагрузкой, дублирования, репликации данных и так далее. 

{% capture notice-2 %}
Выводы:
1. Нужно знать основы организации компьютерной сети.
1. Для некоторых приложений необходимо знать особенности конкретных сетевых протоколов, например, HTTP.
1. Необходимо также отдельно заботиться о согласованности обмена информацией между компонентами приложения. 
1. Написание многопоточных приложений требует специальных усилий по обеспечению потокобезопасности.
1. Также не нужно забывать о вопросах безопасности, конфиденциальности, валидации получаемых данных.
1. Также существуют вопросы управления нагрузкой ваших сервисов и сетевой инфраструктуры.
1. Необходимо также помнить о доступности сети и ограниченности полосы пропускания. 
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


#### Какие основные подходы к их построению?

При создании сетевых приложений первый вопрос, который должен решить для себя разработчик - создание высокоуровневой архитектуры приложений. Из каких частей (модулей) оно будет состоять, как именно они будут обмениваться данными и с кем. Будет ли обмен происходить только между модулями самого приложения или будут предусмотрены обращения к внешним сервисам?

Не затрагивая пока вопросов использования сторонних сервисов и программ, рассмотрим два самых популярных архитектурных паттерна для сетевых приложений. В принципе, любое сетевое приложение может быть либо клиент-серверным, либо распределенным.


![alt_text](/assets/images/np_text/np10-2.png "image_tooltip"){: .align-center style="width: 50%;"}

Самая популярная архитектура сетевых приложений - клиент серверная. Она подразумевает, что приложение состоит из серверной части и клиентской. Сервером мы будем называть именно часть программной системы, модуль, который постоянно (резидентно) выполняется и ждет запросов от клиентов. Когда запрос поступает, сервер его обрабатывает, понимает, что клиент хочет получить и выдает ему ответ. 

При этом может быть одновременно запущенно несколько экземпляров клиентского модуля программы. Но как правило, они все идентичны (во всяком случае, они должны использовать идентичный протокол обмена данными), поэтому нет смысла их рассматривать отдельно, мы будем говорить об одном клиентском модуле.

Клиент в такой схеме - это модуль программы, который непосредственно взаимодействует с пользователем программы и в зависимости от его действий может инициировать соединение с сервером, чтобы произвести определенные операции.

Сервер непосредственно с клиентом не взаимодействует. Его задача - выполнять запросы клиентов. Он в такой схеме является центральным элементом. Распределение функционала между клиентом и сервером - другими словами, какие операции вашей программы должны относиться к клиентской части, а какие к серверной - тоже предмет проектирования. Определенно одно - все, что касается пользовательского интерфеса - это прерогатива клиентской части. В зависимости от задачи вы можете делать клиент более "тонким", то есть оставить только интерфейс и больше ничего (тогда при любых действиях пользователя клиент будет запрашивать сервер и просить его выполнять операции), либо более "толстым" - то есть выносить на клиент часть непосредственного фукнционала приложения. 

Достоинством клиент-серверной архитектуры является ее простота и понятность. Приложение явно делиться на четко обозначенные модули, между ними налаживается довольно типичная схема обмена данными. Но у нее есть и недостатки. Если по каким-то причинам сервер становится недоступен, то полноценно пользоваться приложением нельзя. То есть сервер - это потенциальная точка отказа. 

Тем не менее, на основе клиент-серверного принципа работают большинство сетевых приложений, почи все сетевые службы, на работу с ним ориентированы большинство библиотек и фреймворков. Так что инструменты разработки обычно помогают реализовывать именно такую архитектуру приложений.

![alt_text](/assets/images/np_text/np10-3.png "image_tooltip"){: .align-center style="width: 50%;"}

Альтернативой клиент-серверным приложениям выступают распределенные. В них программа не делится на клиент и сервер, а состоит из множества однотипных модулей, которые совмещают в себе функции и клиента и сервера. Такие модули, будучи запущенными одновременно, могут подсоединяться друг к другу и выполнять обмен данными в произвольном порядке.

Типичным примером распределенных приложений являются пиринговые сети. В них каждый экземпляр приложения может подключаться к любому другому и налаживать многосторонний обмен информацией. Такие приложения образуют сеть подключений, подобно тому, как организован сам Интернет. Такое приложение не зависит от работы центрального сервера и может продолжать функционировать даже если большая часть этой сети будет отсутствовать или будет недоступной.

Несмотря на все достоинства, проектировать, реализовывать и поддерживать распределенные приложения может быть значительно сложнее, чем клиент-серверные. Это происходит потому, что клиент-сервер, более четко определенный протокол, ему нужно лишь следовать и все будет работать так, как предполагается. А в распределенных приложениях все приходится проектировать и продумывать с нуля. 


{% capture notice-2 %}
Выводы:
1. Есть две главные архитектуры построения сетевых приложений - клиент-серверная и распределенная.
1. Сервер - это компьютер, программа или процесс, обеспечивающий доступ к информационным ресурсам.
1. Клиент обычно инициирует соединение и делает запрос к ресурсу.
1. Клиент-серверная архитектура является централизованной со всеми присущими недостатками и преимуществами.
1. Распределенная архитектура может обойти некоторые ограничения централизованной.
1. Распределенные приложения сложнее проектировать и управлять ими.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Основы взаимодействия через сокеты


#### Что такое TCP-сокеты?


![alt_text](/assets/images/np_text/np10-5.png "image_tooltip"){: .align-center style="width: 50%;"}


**Со́кет (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью**.

**Сокеты - это самый базовый механизм сетевого взаимодействия программ, абстрагированный от конкретной реализации сети.** Сокеты работают на транспортном уровне модели OSI - там же, где и протокол TCP и UDP.

Каждый сетевой интерфейс IP-сети имеет уникальный в этой сети адрес (IP-адрес). Упрощенно можно считать, что каждый компьютер в сети Интернет имеет собственный IP-адрес. При этом в рамках одного сетевого интерфейса может быть несколько (до 65536) сетевых портов. Для установления сетевого соединения приложение клиента должно выбрать свободный порт и установить соединение с серверным приложением, которое слушает (listen) порт с определенным номером на удаленном сетевом интерфейсе. **Пара IP-адрес и порт характеризуют сокет (гнездо) - начальную (конечную) точку сетевой коммуникации**. 

**Сокеты могут применяться для связи процессов как на удаленной машине, так и на локальной.** В первом случае, естественно, необходимо, чтобы удаленная машина была доступна по сети. Это можно проверить при помощи команды пинг. Во втором случае сокеты могут выступать как механизм межпроцессного взаимодействия. Или вы можете использовать одну машину для всех процессов-компонентов вашей программной системы, например, для отладки в процессе разработки. 

**Для создания соединения TCP/IP необходимо два сокета: один на локальной машине, а другой - на удаленной.** Таким образом, каждое сетевое соединение имеет IP-адрес и порт на локальной машине, а также IP-адрес и порт на удаленной машине. Как правило, порт локальной машины (исходящий порт) не так важен и его номер не особенно используется в практике. Но порт серверного сокета - это важная информация

**Сокеты могут быть клиентские и серверные.** Серверный сокет - это функция в программе, которая сидит на определенном порту и “слушает” входящие соединения. Процедура создания серверного сокета аналогична вводу текста из консоли: программа блокируется до тех пор, пока пользователь не ввел что-то. Когда это случилось, программа разблокируется и может продолжать выполнение и обработку полученных данных. Также и серверный сокет: ждет, когда к нему подключится клиент и тогда продолжает выполнение программы и может считывать данные из сокета (которые послал клиент) и отправлять данные в сокет. Клиентский же сокет, наоборот, сразу пытается подключиться к определенном узлу сети (это может быть локальная машина, или, чаще, удаленный компьютер) и на определенный сетевой порт. Если на этой машине на этом порту “сидит” серверный сокет, то подключение происходит успешно. Если же данный сокет никем не прослушивается, то процедура подключения возвращает ошибку.

**В языке программирования Python существует стандартный модуль socket, который реализует все необходимые функции для организации обмена сообщениями через сокеты.** Для его использования его достаточно импортировать (так как это модуль стандартной библиотеки, устанавливать его не нужно, он идет в поставке с дистрибутивом Python):


```python
import socket
```

Для начала построения сетевого взаимодействия необходимо создать сокет:


```python
sock = socket.socket()
```

Здесь ничего особенного нет и данная часть является общей и для клиентских и для серверных сокетов. Дальше мы будем писать код отдельно для сервера и для клиента. 

Существует несколько видов сокетов, которые немного различаются по сфере применения и деталях реализации. Самыми распространенными являются Интернет-сокеты. Они используются для пересылки информации между процессами. Есть еще сокеты UNIX, они не используют Интернет-протоколы для обмена сообщениями, и используются для организации межпроцессного взаимодействия.

Также среди Интернер сокетов существуют потоковые и датаграммные сокеты.
Датаграммные сокеты называют “сокеты без соединения”, они используют протокол UDP вместо TCP. Потоковые сокеты обеспечивают гарантированную  доставку, очередность сообщений, они более надежны. Протокол HTTP использует именно потоковые сокеты для соединения клиента с сервером. UDP обычно используется для передачи потокового медиа, когда скорость критичнее риска потери единичных пакетов.

{% capture notice-2 %}
Выводы:
1. Сокеты - это базовый механизм сетевого взаимодействия программ.
1. Для работы сокетов не нужно специальное программное обеспечение, они работают на уровне операционных систем.
1. Сокет состоит из адреса хоста и номера сетевого порта.
1. Для соединения необходимо создать два сокета - в двух модуля программы, которые нужно соединить.
1. Стандартный модуль Python socket позволяет создавать сокеты и работать с ними.
1. Еще отдельный вид сокетов применяется для организации межпроцессного взаимодействия в \*nix системах.
1. Сокеты могут использовать протокол TCP либо UDP.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


#### Каковы правила использования номеров портов?

Для эффективного использования сетевых сокетов необходимо вспомнить концепцию сетевых портов, так как сокеты их активно используют. 

![alt_text](/assets/images/np_text/np10-7.png "image_tooltip"){: .align-center style="width: 50%;"}

IP-адрес или любой другой способ адресации хоста позволяет нам идентифицировать узел сети. Номер порта позволяет указать конкретное приложение на этом хосте, которому предназначен пакет. Номер порта нужен, так как на любом компьютере может быть одновременно запущено множество приложений, осуществляющих обмен данными по сети. Если использовать аналогию с почтовыми адресами, то IP-адрес - это номер дома, а порт - это номер квартиры в этом доме. 

Номер порта - это всего лишь 16-битное число, которое указывается в пакете, передающемся по сети. Не нужно путать сетевой порт с физическими разъемами, это чисто программная концепция.

Так как на номер порта отведено 16 бит, существует всего 65536 возможных портов. Причем, номера портов отдельно считаются по протоколам TCP и UDP. Таким образом, на компьютере одновременно может существовать более 130 тысяч процессов, обменивающихся данными. На практике, свободных портов всегда в избытке и хватает даже для работы множества высоконагруженных серверов. 

Но не все номера портов созданы равными. Первые 1024 являются “системными” и используются в основном стандартными приложениями. Существует общепринятое соглашение, какие сетевые службы используют системные порты. Например, служба веб-сервера по умолчанию использует 80 порт для соединений по протоколу HTTP и 443 - для протокола HTTPS. Служба SSH использует порт номер 22. И так далее. Любая стандартная сетевая служба имеет некоторый порт по умолчанию. Кстати, хорошим показателем практикующего администратора является запоминание часто используемых номеров стандартных портов. Специально это учить не нужно, только если вы не хотите блеснуть знаниями на собеседовании.

Для использования системных портов обычно требуются повышенные привилегии. Это сделано для того, чтобы обычные пользователи не "забивали" стандартные порты и не мешали работе системных сетевых служб. Мы вообще не рекомендуем использовать системные порты. Остальные  могут использоваться совершенно произвольно и их более чем достаточно для повседневных нужд.

Кстати, хоть сетевые службы используют определенные стандартные порты, они вполне могут быть переназначены на свободные. Служба не "привязана" к номеру порта, это легко регулируется настройками. Например, строго рекомендуется при настройке службы SSH менять стандартный 22 порт на случайный для повышения безопасности.

Порты назначаются процессу при попытке открыть серверный сокет. В этот момент происходит связывание сокета с номером порта, который выбрал программист. Помните, что если вы пытаетесь использовать занятый порт, то это спровоцирует программную ошибку. Поэтому в реальных приложениях стоит сначала проверять, свободен ли порт или нет, либо (что гораздо проще) обрабатывать исключение при попытке связаться с занятым портом.

Сетевые администраторы могут в целях безопасности блокировать соединения на некоторые порты. Так же поступают и программы-файерволлы. Это требуется для повышения безопасности сервера. Вообще, по умолчанию, все порты "закрыты", то есть подключения к ним блокируется файерволлом. При необходимости системный администратор может "открыть" обмен данными по определенному номеру порта в настройках файерволла. Это следует учитывать при попытках подключения к удаленным машинам. 

{% capture notice-2 %}
Выводы:
1. Порт - это всего лишь число в IP-пакете.
1. Номер порта нужен, чтобы обратиться к определенному процессу на конкретном хосте.
1. Всего существует 65536 TCP-портов и 65536 UDP-портов.
1. Первые 1024 порта являются системными - их можно использовать только администраторам.
1. Распространенные сетевые службы имеют стандартные номера портов, их лучше не занимать.
1. Порт назначается при открытии серверного сокета. Можно занять только свободный порт.
1. Системные администраторы, программы-файерволлы могут заблокировать, "закрыть" обмен данными по номерам портов.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


#### Почему стоит начать именно с изучения сокетов?


![alt_text](/assets/images/np_text/np10-8.png "image_tooltip")


Использование сокетов позволяет строить приложения, обменивающиеся данными по сети, но при этом не требующие специального программного обеспечения.

Чтобы написать веб-приложение, нам нужен веб-клиент и веб-сервер, настроенные и готовые к работе. Такая же ситуация с любой другой службой Интернета.

Сокеты - это компромиссный вариант.

Более высокоуровневые механизмы требуют установленного и настроенного специального программного обеспечения. Даже если вы планируете использовать в профессиональной деятельности прикладные протоколы, все они в основе своей работы используют механизм сокетов, так что его понимание будет полезно всем.

Более низкоуровневые протоколы не абстрагируются от конкретной реализации сети.

{% capture notice-2 %}
Выводы:
1. Сокеты не требуют специального программного обеспечения.
1. Сокеты не зависят от конкретной физической реализации сети.
1. Сокеты хороши для понимания основ сетевого взаимодействия.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


#### Как организуется обмен данными через сокеты?


![alt_text](/assets/images/np_text/np10-9.png "image_tooltip")


Для соединения необходимо создать два сокет - серверный и клиентский. Они могут быть созданы в разных процессах.

Работа с сокетами происходит через механизм системных вызовов. Все эти вызовы аналогичны вызовам, осуществляющим операции с файлами. Список этих вызовов определен в стандарте POSIX и не зависит от используемой операционной системы или языка программирования. 

Первым создается серверный сокет. Он назначается на определенный порт и начинает его ожидать (прослушивать) входящие соединения.

Прослушивание порта - это блокирующая операция.

После этого создается клиентский сокет. Клиент может подключиться к серверному сокету по адресу и номеру порта. Если этот порт является открытым (то есть его прослушивает какой-то процесс), то произойдет соединение и на сервере выполнится метод accept.

После этого устанавливается двунаправленное соединение, которое можно использовать для чтения и записи данных. Интерфейс взаимодействия с сокетом очень похож на файловые операции, только при записи информации, она не сохраняется на диск, а посылается в сокет, откуда может быть прочитана другой стороной.

После соединения можно отправлять или получать информацию из сокета. Чтение информации из сокета - это блокирующая операция.

{% capture notice-2 %}
Выводы:
1. Серверный сокет назначается на определенный свободный порт и ждет входящих соединений.
1. Клиентский сокет сразу соединяется с северным. Тот должен уже существовать.
1. Сокет - это двунаправленное соединение. В него можно читать и писать, как в файл.
1. Сокет - это битовый протокол, строки нужно определенным образом кодировать в битовый массив пред отправкой.
1. После использования сокет нужно закрыть, иначе порт будет считаться занятым.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Простейшие клиент и сервер


#### Что мы хотим сделать?


![alt_text](/assets/images/np_text/np10-10.png "image_tooltip")


Мы хотим реализовать простейший пример сетевого взаимодействия - пару процессов, которые связываются между собой.

Мы будем организовывать один набор сокетов. Так что один из них должен быть клиентским, а другой - серверным. 

Поэтому один процесс мы будем называть сервером, а другой - клиентом. Однако, такое разделение условно и одна и та же программа может выступать и клиентом для одного взаимодействия и сервером - для другого. **Можно сказать, что клиент и сервер - это просто роли в сетевом взаимодействии.**

Инициирует соединение клиент.

Первым должен быть запущен сервер, а затем клиент.


#### Как создать такой сервер?


```python
#!/usr/bin/env python
import socket
sock = socket.socket()
sock.bind(('', 9090))
sock.listen(1)
conn, addr = sock.accept()
print 'connected:', addr
while True:
    data = conn.recv(1024)
    if not data:
        break
    conn.send(data.upper())
conn.close()
```

Для начала нам нужно определиться, какой порт будет использовать наш сервер.

Еще один параметр - сетевой интерфейс. Если оставить эту строку пустой, то сервер будет доступен для всех сетевых интерфейсов. 

Для примера выберем порт 9090. 

**Теперь свяжем наш сокет с данными хостом и портом с помощью метода bind**, которому передается кортеж, первый элемент (или нулевой, если считать от нуля) которого — хост, а второй — порт. Обратите внимание, что метод bind принимает кортеж из двух элементов - имя хоста и номер порта.


```python
sock.bind(('', 9090))
```

Теперь у нас все готово, чтобы принимать соединения.** С помощью метода listen мы запустим для данного сокета режим прослушивания.** Метод принимает один аргумент — максимальное количество подключений в очереди. Установим его в единицу. 


```python
sock.listen(1)
```

Обратите внимание, что это блокирующая операция.

Теперь, мы можем принять подключение с помощью метода accept, который возвращает кортеж с двумя элементами: новый сокет и адрес клиента. Именно этот сокет и будет использоваться для приема и посылке клиенту данных. Так как данная операция идет после listen, она будет выполнена только тогда, когда сервер получит входящее соединение от клиента. 


```python
conn, addr = sock.accept()
```

Так мы установили с клиентом связь и можем с ним общаться. **В данном простейшем примере мы будем получать данные от клиента небольшими порциями в бесконечном цикле, чтобы получить любой объем данных, который клиент может нам послать**. Чтобы получить данные нужно воспользоваться методом recv, который в качестве аргумента принимает количество байт для чтения. Мы будем читать порциями по 1024 байт (или 1 кб):


```python
while True:
    data = conn.recv(1024)
    if not data:
        break
    conn.send(data.upper())
```

**Метод recv() тоже является блокирующей операцией.**

**Для общения с клиентом мы используем сокет, который получили в результате выполнения метода accept.** Мы в бесконечном цикле принимаем 1024 байт данных с помощью метода recv. Если данных больше нет, то этот метод ничего не возвращает. Таким образом мы можем получать от клиента любое количество данных.

**Дальше в нашем примере для наглядности мы что-то сделаем с полученными данными и отправим их обратно клиенту.** Например, с помощью метода upper у строк вернем клиенту строку в верхнем регистре.

**После получения порции данных и отсылки их обратно клиенту можно и закрыть соединение**:


```python
conn.close()
```

На этом написание сервера закончено. Он принимает соединение, принимает от клиента данные, возвращает их в виде строки в верхнем регистре и закрывает соединение. 


#### Как создать такой клиент?


```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import socket

sock = socket.socket()
sock.connect(('localhost', 9090))
sock.send('hello, world!')

data = sock.recv(1024)
sock.close()

print data
```

Клиентское приложение еще короче. 

Клиент использует точно такой же объект socket.

Вместо прослушивания порта мы сразу осуществляем соединение. Для этого указывается IP-адрес хоста, на котором запущен сервер и номер порта, который он прослушивает. 

При неуспешном соединении метод listen выбросит исключение. Существует несколько причин - хост может быть недоступен по сети, порт может не прослушиваться никаким процессом.

Послание данных в сокет осуществляется методом send.

Дальше мы читаем 1024 байт данных и закрываем сокет. Для большей надежности чтение данных можно организовать так же как на сервере - в цикле. 

#### Какие ограничения данного подхода?
Сервер выполняет только одну операцию.
К серверу может подключиться только один клиент.
После разрыва соединения сервер завершает свою работу.

#### Как задать таймаут прослушивания?

~~~py
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(("",0))
sock.listen(1)
# accept can throw socket.timeout
sock.settimeout(5.0)
conn, addr = sock.accept()
 
# recv can throw socket.timeout
conn.settimeout(5.0)
conn.recv(1024)
~~~

#### В чем особенности UDP-сокетов?

```py
import socket
port = 5000
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((&quot;&quot;, port))
print &quot;waiting on port:&quot;, port
while 1:
    data, addr = s.recvfrom(1024)
    print data

import socket   #for sockets
import sys  #for exit
 
# create dgram udp socket
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
except socket.error:
    print 'Failed to create socket'
    sys.exit()
 
host = 'localhost';
port = 8888;
 
while(1) :
    msg = raw_input('Enter message to send : ')
    
    try :
        #Set the whole string
        s.sendto(msg, (host, port))
        
        # receive data from client (data, addr)
        d = s.recvfrom(1024)
        reply = d[0]
        addr = d[1]
        
        print 'Server reply : ' + reply
    
    except socket.error, msg:
        print 'Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
        sys.exit()
```

#### Как обойти буферизацию?

```py
import socket
 
HEADERSIZE = 10
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((socket.gethostname(), 1243))
s.listen(5)
 
while True:
    # now our endpoint knows about the OTHER endpoint.
    clientsocket, address = s.accept()
    print(f"Connection from {address} has been established.")
 
    msg = "Welcome to the server!"
    msg = f"{len(msg):<{HEADERSIZE}}"+msg
 
    clientsocket.send(bytes(msg,"utf-8"))

import socket
 
HEADERSIZE = 10
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((socket.gethostname(), 1243))
 
while True:
    full_msg = ''
    new_msg = True
    while True:
        msg = s.recv(16)
        if new_msg:
            print("new msg len:",msg[:HEADERSIZE])
            msglen = int(msg[:HEADERSIZE])
            new_msg = False
 
        print(f"full message length: {msglen}")
 
        full_msg += msg.decode("utf-8")
 
        print(len(full_msg))
 
 
        if len(full_msg)-HEADERSIZE == msglen:
            print("full msg recvd")
            print(full_msg[HEADERSIZE:])
            new_msg = True
            full_msg = ""
```

#### Как обмениваться объектами по сокетам?

```py
import socket
import time
import pickle
 
HEADERSIZE = 10
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((socket.gethostname(), 1243))
s.listen(5)
 
while True:
    # now our endpoint knows about the OTHER endpoint.
    clientsocket, address = s.accept()
    print(f"Connection from {address} has been established.")
 
    d = {1:"hi", 2: "there"}
    msg = pickle.dumps(d)
    msg = bytes(f"{len(msg):<{HEADERSIZE}}", 'utf-8')+msg
    print(msg)
    clientsocket.send(msg)

```

#### Как сделать сервер многоразовым?

```py
import socket, string
 
def do_something(x):
  lst = map(None, x);
  lst.reverse();
  return string.join(lst, "")
 
HOST = ""                 # localhost
PORT = 33333
srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
srv.bind((HOST, PORT))
while 1:
  print "Слушаю порт 33333"
  srv.listen(1)             
  sock, addr = srv.accept()
  while 1:
    pal = sock.recv(1024)
    if not pal: 
      break
    print "Получено от %s:%s:" % addr, pal
    lap = do_something(pal)
    print "Отправлено %s:%s:" % addr, lap
    sock.send(lap)
  sock.close()
```

#### Как снять блокировку с операции чтения?

```py
# при открытии соединения:
conn = socket.socket()
conn.connect( ("yandex.ru", 80) )
conn.setblocking(0)
 
# в скрипте, читающем данные:
try: data = conn.recv(1024)
except socket.error: # данных нет
    pass # тут ставим код выхода
else: # данные есть
    print(data)
```

