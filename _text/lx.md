---
title: "Черновик учебника"
---


## Управление файлами


### Как организована структура каталогов Linux?

Одно из самых базовых понятий для любой операционной системы - это файл. Обычно, мы подразумеваем под файлом некоторое количество информации, хранящееся в постоянном хранилище (на диске), имеющее имя. Однако, Linux построена таким образом, что практически любой объект, с которым работает операционная система является файлом. Привычные нам файлы здесь называются обычными, но кроме них еще существует несколько типов, которые Linux также называет файлами, хотя с точки зрения обывателя они воспринимаются как что-то другое. Например, любое физическое устройство имеет в операционной системе особое логическое представление в виде файла в определенной папке. Вы можете зайти в эту папку и просмотреть список устройств, зайти в конкретный файл и увидеть свойства этого устройства. Однако это не просто статическая информация, хранящиеся на диске. Это динамический объект операционной системы, на диске он не занимает никакого места, его там нет. При обращении к этому файлу происходит вызов особых функция ядра ОС. Кроме этого для Linux папки, ссылки (аналог ярлыков), даже процессы самой ОС - тоже файлы. 

Это сделано для унификации доступа к различным ресурсам операционной системы. Зачем придумывать особый механизм отправки документов на печать, если можно просто записать текст в файл принтера. Такой подход может немного запутывать сначала, но довольно быстро привыкаешь, что для Linux практически любой объект - это файл. Но довольно часто приходится оговариваться, имеется в виду файл в узком смысле, обычный файл, как информация на диске с именем, или в широком смысле, как концепция операционной системы.

Понятно, что файлов в каждой отдельно взятой операционной системе может быть огромное количество. И только малая часть из этого - файлы пользователей. Кроме этого существуют служебные файлы операционной системы, конфигурационные файлы, файлы системных и прикладных программ, псевдофайлы, которые мы обсуждали ранее. Если бы файлы имели только имя, ориентироваться в этой куче было бы решительно невозможно. Для этого и нужны папки. Папки, они же директории или каталоги, служат для объединения произвольного количества файлов во множество в некоторым именем. Неудивительно, что для Linux папка - это тоже файл, его особый тип. Фактически, папка - это файл, содержащий список других файлов, которые в считаются “в этой папке”. Так что сами папки тоже можно “класть” в другие папки. Таким образом, структура файлов и папок образует иерархическую структуру-  дерево файловой системы. 

А что происходит с файлами и папками, которые не  находятся в других папках? В Linux существует специальная корневая папка. Она обозначается прямым слешем (/). Она является вершиной этой иерархии, корнем дерева, единой точкой отсчета для всех других папок на данном компьютере. Так что любой файл находится в какой-то папке, либо в в корневой директории, либо в каком-то каталоге, который может быть в другом каталоге, и так далее, но в итоге все равно в корневой папке.

Таким образом, для того чтобы указать на какой-то конкретный файл нам недостаточно его имени, еще нужен его “адрес” - путь от корневой директории по (возможно нескольким) вложенным папкам до самого файла. Такой адрес называется “путь” к файлу. У каждого файла, который находится в операционной системе существует один и только один абсолютный путь от корневой директории. Заметьте, кстати, что конкретный файл не может находится в нескольких разных папках одновременно, то есть в двух местах сразу.

Все пути в Linux отсчитываются от корня файловой системы, обозначаемого прямым слешем /. Корень всегда один, не существует никаких букв дисков, как в Windows. Корень еще называют корневой папкой или директорией, так как именно в нем содержаться все другие папки. В пути к файлу последовательно указываются папки, которые нужно пройти, чтобы найти файл, а затем - имя самого файла. Имена папок и файла разделяются прямым слешем. Так, в пути /etc/passwd первый символ / обозначает корневой каталог, etc - имя папки в корневом каталоге, passwd - имя нужного нам файла. Обратите внимание, что в Linux не принято использовать расширения в именах файлов (но, впрочем, и не запрещено, так что ими многие пользуются). 

В корневой папке обычно не хранятся обычный файлы, только папки. Причем папки корневой директории несут особую смысловую нагрузку. Например, каталог /etc/ хранит текстовые конфигурационные файлы самой операционной системы, а каталог /dev/ - те самые псевдофайлы-устройства, о которых мы уже упоминали. Этот набор стандартных папок немного меняется от дистрибутива к дистрибутиву, но основные остаются общими. Существует даже специальный стандарт - Lnux FHS (filesystem hierarchy standard), который и описывает набор и предназначение стандартных папок корневой директории.

Выводы:

1. Для Linux практически любой объект - файл.
2. В Linux файлы организованы привычным образом в папки и подпапки, образуя иерархическую структуру - дерево файловой системы.
3. Корневая папка / - это единая точка отсчета для всех папок.
4. Каждый файл имеет один и только один адрес в файловой системе - абсолютный путь к нему.
5. Для разделения имен папок и файлов в Linux используется только прямой слеш.
6. В Linux принята стандартная структура файлов.


### Что такое относительные и абсолютные пути?

Для того, чтобы операционная система, программы и пользователи могли работать с файлами и обращаться к ним у каждого файла должен быть уникальный идентификатор. Но просто имени недостаточно, потому что могут существовать несколько файлов с одинаковыми именами. Поэтому операционная система обращается к файлам используя пути.

Путь к файлу можно задавать двумя способами - абсолютным или относительным. Абсолютный путь начинается с символа / и отсчитывается от корневого каталога. Относительный путь начинается с имени папки и отсчитывается от текущего каталога. Это сделано для удобства указания пути, чтобы не повторять одно и то же, если вы работаете в данный момент преимущественно с файлами в одной папке. 

При указании путей к файлам можно пользоваться некоторыми сокращениями. Вы можете использовать два специальных имени: точку (.), означающую текущую директорию, и пару точек (..), означающую родительскую директорию текущей директории. Также вы можете использовать символ тильды (~), который означает вашу домашнюю директорию, и сочетание ~username, означающее домашнюю директорию пользователя с именем username.

Помните, что нужно четко представлять себе, где лежит тот или иной файл для того, чтобы с ним работать. Часто /etc/passwd и etc/passwd - это два совершенно разных файла в разных местах. Поэтому нужно всегда четко представлять себе расположение нужного вам файла относительно текущей директории и использовать относительные или абсолютные пути правильно, не путая их.

Может показаться, что для простоты и надежности следует всегда использовать абсолютные пути. Однако относительный формат был придуман не просто так. С одной стороны, он добавляет удобства и скорости работы в командной строке, так как абсолютные пути могут быть очень длинными и в них легко ошибиться ил опечататься. Именно для этого придумано понятие текущей папки - это просто название папки, которое автоматически поставляется в относительные пути, чтобы получить абсолютный. 

Но у относительных путей есть и еще одно применение. Представьте, что вы пишите скрипт или программу, которая работает с файлами в какой-то своей папке. У рабочей папки программы может быть разное расположение на разных компьютерах, или оно может поменяться если вы просто перенесете программу в другое место. Если вы используете абсолютные пути, то при каждом таком переносе программа просто сломается. То есть абсолютные пути слишком зависят от положения точки отсчета и делают программу непереносимой. Использование же относительных путей решает эту проблему - при переносе программы в другое место вся внутренняя структура папок сохранится и программа будет работать корректно без необходимости менять исходный код.Рекомендуется

Выводы:



1. У каждого файла в системе есть один уникальный адрес.
2. Следует различать абсолютные и относительные пути к файлам.
3. Абсолютный путь отсчитывается от корня файловой системы и не зависит от того, где находится пользователь.
4. Относительный путь отсчитывается от текущей директории пользователя.
5. Смысл переходить по директориям как раз в том, чтобы относительные пути были короче.
6. Лучше использовать относительные пути в программах и скрипта для переносимости. 


### Какие виды файлов существуют?

Мы уже говорили раньше, что UNIX-подобные операционные системы представляют многие разные объекты, с которыми приходится работать в виде файлов. Это удобно и для операционной системы и для пользователей. Давайте кратко перечислим основные виды файлов и их зачем они нужны. Посмотреть тип файла всегда можно командой ls -l. В строке соответствующей файлу самый первый символ, один из атрибутов файла, указывает его тип.

Обратите внимание, что тип файла - это не расширение, как в Windows. Там расширение является обязательным элементом имени файла и показывает операционной системе, какой программой его нужно “открывать”, то есть обрабатывать его содержимое. Другими словами, расширение файла характеризует характер содержимого этого файла. В UNIX принята другая система. Изначально вы запускаете программы командами в терминале, то есть явно указываете название программы, которая должна запуститься и обрабатывать тот или иной файл. Поэтому расширение для операционной системы необязательно. Но с распространением графических интерфейсов, когда пользователи привыкают открывать файл щелчком мыши, практика использования расширений в именах файлов начинает распространяться и на Linux. Так почти все графические окружения поддерживают ассоциации файлов с программами через расширения, как в Windows. Кроме того, это удобно пользователю, так как глядя на имя файла он может предположить, что за информация там хранится.

Самый простой тип файла так и называется - обычный файл. Он помечается символом дефиса (-). Это именованная область данных на носителе, которая может содержать произвольную информацию. Часто чтобы не путаться этот тип файлов называется документом, хотя в Linux к обычным файлам относятся и мультимедийные, и офисные, и исполняемые файлы программ и файлы с исходным текстом программ и скриптов. Короче говоря, все, что в Windows называется файлом, в Linux - обычный файл.

Мы уже говорили, что папки в UNIX - это тоже файлы. Это второй по распространенности тип файлов - папки, директории или каталоги. Это все разные названия одного и того же. Они служат для организации файлов и упрощения навигации по файловой системе. В Linux папки - это по сути просто специальный файл, который содержит список других файлов, которые считаются “лежащими” в этой папке. Файл типа каталога помещается символом d.

Еще один тип файлов - это ссылки. Они помечаются символом l (link). Ссылки вместо пользовательских данных содержат путь к другому файлу. Именно этот файл будет открываться при обращении к ссылке. Этот механизм работает аналогично ярлыкам в Windows. Ссылки нужны для более удобной организации файлов, иногда бывает полезно иметь доступ к одному и тому же файлу из разных мест, то есть папок. Можно, конечно, файл просто скопировать, но копирование файлов расходует место на диске и при изменении одной копии вторая останется старой. Надо понимать, что при удалении или перемещении исходного файла все ссылки на него, если такие есть, перестанут работать. Такие ссылки называются битыми.

Надо сказать, что все это относится к так называемым символическим, или мягким ссылкам. Именно они работают подобно ярлыкам. Но в Linux есть и другой тип ссылок - жесткие ссылки. Жесткие ссылки работают совершенно по-другому и на другом уровне. По сути дела - это просто другое имя одного и того же файла. Любой файл имеет как минимум одну жесткую ссылку на него - это само имя файла. Но вы можете создать новую ссылку. И для операционной системы все жесткие ссылки на файл являются равноправными, в отличие от символических, где есть сам файл и ссылки на него. Даже если вы удалите файл по первоначальному имени, если на него есть еще жесткие ссылки, он проложит существовать. Файл удаляется тогда, когда перестает существовать последняя жесткая ссылка на него.

Еще один тип файлов в UNIX - это специальные файлы устройств. Их можно распознать по символу c или b в атрибутах. 

Выводы:



1. Обычные файлы содержат информацию в виде данных или программного кода.
2. В Linux тип файла - это не расширение, они вообще не обязательны.
3. Директории, каталоги или папки - это список файлов.
4. Ссылки используются для удобства нахождения файла в нескольких папках одновременно.
5. Символические ссылки - это как ярлыки в Windows.
6. Жесткие ссылки - это два адреса одного и того же файла.
7. Сокеты используются для взаимодействия между процессами.


### Как работать с файлами в консоли?

Выводы:



1. Создание, удаление, копирование, перемещение файлов изучалось ранее.
2. Создать жесткую ссылку на файл можно командой ln.
3. Файл существует до тех пор, пока на него есть хотя бы одна жесткая ссылка.
4. Создать символическую ссылку на файл можно командой ln -s.
5. Если удалить символическую ссылку исходный файл останется нетронутым.
6. Если удалить сам файл, то все символические ссылки на него станут недействующими.
7. Можно перенаправить результат команды в файл при помощи > или \>\>.
8. Можно направить содержимое файла на вход команде при помощи &lt;.
9. Объединять команды можно при помощи конвейера \|.


### Как работать с архивами?

Выводы:



1. Команда tar -xvf archive.tar распаковывает архив в текущую директорию.
2. Команда tar -cvzf archive.tar file1 file2 file3 создает архив из перечисленных файлов.
3. Команда zip file1 сжимает файл в архив.
4. Команда zip -r archive.zip directory1 directory2 directory3 позволяет сделать архив из папок.
5. Команда unzip file1.zip распаковывает архив


### Как найти нужный файл?

Выводы:



1. find [directory] -size [set minimum size]
2. find /home/ -size +1000000k
3. Команда apropos [keyword] производит поиск в мануале по ключевым словам.
4. Команда locate является более быстрой альтернативой find.
5. Команда wget [url] позволяет скачать файл из Интернета.


### Как сделать резервную копию?



1. Программа Rsync используется для инкрементального резервного копирования.
2. Команда rsync -a -v -r /source/ /destination/ копирует содержимое одной папки в другую.
3. Rsync позволяет копировать с или на удаленный хост используя протокол SSH.
4. Синхронизация с удаленным хостом выполняется командой rsync -avz /tmp/ root@192.168.56.102:/home/
5. Для работы с удаленным сервером там должен быть установлен и настроен сервер rsync.


## Удаленный доступ по SSH


### Зачем нужен протокол SSH?



1. При работе часто возникает потребность выполнять операции на разных удаленных хостах.
2. Обычное незащищенное соединение для этого не подходит из-за проблем с безопасностью.
3. Протокол SSH позволяет выполнять команды терминала на удаленной машине.
4. Протокол SSH начинает шифровать соединение еще до ввода пароля пользователя.
5. SSH работает на основании алгоритмов асимметричного шифрования.
6. Таким образом можно подключаться к любым машинам, физическим и виртуальным.
7. SSH является клиент-серверным протоколом. На локальной машине работает клиент ssh, на удаленной - сервер.


### Что нужно для успешного удаленного доступа?



1. Необходимо знать логин и пароль пользователя на удаленной машине.
2. Нужно, чтобы удаленная машина была доступна по сети.
3. Нужно, чтобы на удаленной машине работал сервер SSH.
4. Самый распространенный сервер - OpenSSH - бесплатный и открытый.
5. Системные администраторы могут заблокировать доступ к порту ssh.
6. По умолчанию, порты обычно закрыты, нужно их открыть.
7. Нужно знать IP-адрес и порт (по умолчанию, 22) удаленной машины.
8. На локальной машине должен быть установлен клиент ssh.
9. Есть консольные и графические клиенты ssh, но работать все равно придется в терминале.


### Как подключиться к серверу из командной строки?



1. Команда ssh username@remote_host осуществляет подключение к удаленному терминалу.
2. Если вы подключились к этому компьютеру первый раз, нужно будет подтвердить его.
3. Опция -p позволяет подключиться по любому номеру порта.
4. После установки соединения вам нужно будет ввести пароль от удаленной учетной записи.
5. После этого вы сможете работать в командной строке так же, как и на локальной машине.
6. Для выхода из удаленного сеанса есть команда exit или сочетание Ctrl + D.


### Как подключиться к серверу по ключу?



1. Запоминать много паролей от серверов часто неудобно и небезопасно.
2. Асимметричное шифрование позволяет избежать ввода пароля каждый раз.
3. Команда ssh-keygen позволяет сгенерировать пару ключей - приватный и публичный.
4. Приватный ключ надо хранить в секрете. Если он скомпрометирован, придется создавать новую пару.
5. Публичный ключ может удостоверять подлинность отправителя.
6. Можно скопировать публичный ключ на сервер командой ssh-copy-id -i.
7. Ключ может быть разослан на несколько серверов, и на них можно заходить без пароля.
8. Ключ тоже можно защитить паролем.


### Как запомнить частые подключения?



1. Файл ~/.ssh/config используется, чтобы запомнить часто использующиеся подключения.
2. Можно присвоить символьное имя и связать его с адресом, именем пользователя.
3. В этом файле можно прописать использование определенного файла ключа.
4. SSH может использоваться для авторизации на сторонних сервисах.
5. Файл приватного ключа в таком случае выступает идентификацией (identity).


### Зачем нужна программа Tmux?



1. При отключении от удаленного хоста все запущенные процессы завершатся.
2. Иногда нужно запустить процесс так, чтобы он продолжался на сервере после отключения.
3. Для этого существуют специальные резидентные программы, например, tmux.
4. Tmux организует сессии, которые продолжаются даже после отключения пользователя.
5. Также вы можете продолжать работу с того места, с которого отключились.
6. Tmux позволяет создавать несколько вкладок, разбивать окно терминала на области.
7. Tmux сильно упрощает работу с терминалом и с удаленными серверами.
8. Для работы tmux должен быть установлен на удаленном сервере.


## Пользователи и права


### Зачем нужно разделение доступа?

Современные операционные системы рассчитаны на использование многими пользователями одновременно. Раньше такое разделение использовалось когда компьютеры были слишком дорогими, чтобы обеспечивать ими всех работников и несколько человек могли по сети подключиться к одной рабочей станции, чтобы работать с ней. 

При работе нескольких пользователей за одной машиной необходимо разделить их полномочия. Во-первых, пользователи не должны иметь право вмешиваться в работу системы в целом. Например, если один пользователь захочет удалить установленную в системе программу, это может затронуть работу других пользователей, которые эту программу используют. Во-вторых, пользователи должны сами решать, показывать ли свои файлы и папки другим пользователям. 

Естественно, должны существовать пользователи с расширенным набором полномочий, которые могут осуществлять обслуживание системы в целом. Обычно это системные администраторы, которые ответственны за техническое состояние системы. Обычно они же управляют полномочиями пользователей: определяют, что могут, а чего не могут делать рядовые пользователи.

Сейчас, в эру персональных компьютеров когда за Вашим личным компьютером вряд ли работает много малознакомых человек, многопользовательская работа используется для двух основных сценариев:



1. Если мы говорим о пользовательских устройствах, то часто пользователи используются для разделения доступа между приложениями. Например, в ОС Android для каждого установленного приложения регистрируется новый пользователь. Таким образом, одно приложение не может вмешаться в работу другого и в работу системы в целом.
2. На серверных компьютерах все еще зачастую работают несколько человек, как системных администраторов, так и неограниченный круг пользователей, которые могут подключаться к серверу по сети и иметь доступ к некоторым данным и сервисам этого сервера. Даже на ваш персональный компьютер могут подключиться пользователи и процессы по сети и им необходимо как-то ограничить возможность действий в операционной системе.

Выводы:



1. Современные компьютеры могут использоваться несколькими пользователями одновременно.
2. Поэтому должно быть разделение и ограничение доступа к ресурсам.
3. Ресурсы - это файлы, устройства, сеть. В Linux - это все файлы.
4. Должен существовать пользователь с расширенными полномочиями.
5. Пользователи могут применяться для разделения доступа между приложениями.
6. Каждый пользователь имеет свои полномочия в системе - права доступа.
7. Необходимо придерживаться принципа минимальных прав.


### Что такое пользователь?

Для операционной системы, пользователь - это тот, кто авторизовался в системе. Авторизация - это процесс сопоставления пользователя одной из учетных записей, хранящихся в системе.

Авторизация обычно построена на вводе в систему одного из возможных секретов:



1. То, что пользователь знает - авторизация по паролю или ключевой фразе. Это технически самый простой вид авторизации до сих пор широко распространен.
2. То, что пользователь имеет - физический ключ, содержащий электронный криптографический сертификат. Это развитие предыдущего способа, когда конкретный секрет скрыт для безопасности от пользователя и воплощен в какой-то физической форме.
3. То, чем пользователь является - биометрическая аутентификация. Еще недавно этот способ был очень дорогим из-за нераспространенности специализированного оборудования. Сейчас он используется все чаще, так как биометрические датчики встроены во многие смартфоны. Очень часто он используется в сочетании с другими способами (двухфакторная аутентификация).

Выводы:



1. Пользователь для ОС - это учетная запись с именем и способом аутентификации.
2. Обычно применяется аутентификация по паролю.
3. Для начала работы в системе необходимо залогиниться - пройти аутентификацию.
4. Все процессы, которые запускает пользователь выполняются от его имени и с его правами.
5. Система аутентификации встроена в само ядро операционной системы.


### Где хранится информация о пользователях?



1. В Linux информация о всех пользователях хранится в файле /etc/passwd.
2. Изначально он хранил пароли, но их давно оттуда убрали для безопасности и удобства.
3. У каждого пользователя есть идентификатор - UID.
4. У каждого пользователя есть символьное имя - логин.
5. У пользователя может быть задан пароль на вход в систему.
6. У пользователя может быть домашняя папка, интерпретатор по умолчанию.
7. Еще можно задать много дополнительной информации - номер кабинета, телефона.


### Зачем нужны группы?



1. Группы были придуманы для удобства назначения прав доступа нескольким пользователям.
2. В настоящее время группы используются не очень часто.
3. Гораздо чаще создается специальный пользователь с нужными правами.
4. Любой пользователь может быть членом одной или нескольких групп. 
5. Информация о группах хранится в файле /etc/group.
6. При создании пользователя автоматически создается группа с таким же именем.
7. Существует группа sudoers или sudousers - только ее члены могут использовать sudo.


### Какие основные действия с пользователями и группами?



1. Команда useradd регистрирует нового пользователя в систему и все.
2. Команда adduser более полная - создает пользователя, домашнюю папку, задает ему пароль.
3. Команда userdel позволяет удалить пользователя.
4. Команда passwd используется для изменения пароля пользователя. 
5. Пользователь может изменить свой пароль, суперпользователь может сменить пароль кому угодно.
6. Команда usermod может изменить параметры пользователя.
7. usermod -a -G добавляет пользователя в группу.


### Что такое суперпользователь?



1. Суперпользователь root - это специальный пользователь, который всегда существует.
2. Для рута не выполняются никакие проверки прав доступа - он может все.
3. Рут даже сам не может себе ничего запретить.
4. Суперпользователь нужен для проведения действий, затрагивающих всю систему.
5. Очень не рекомендуется постоянно работать в сеансе суперпользователя - опасно.
6. Лучше пользоваться командой sudo время от времени.
7. На некоторых системах даже запрещен вход в графический режим под рутом.
8. Команда last выводит информацию о нескольких последних авторизациях.
9. Команда w или who показывает, кто авторизован на компьютере прямо сейчас.


### Что такое права доступа?



1. У каждого файла есть владелец и группа-владелец, которые задаются при создании файла.
2. По отношению к файлу пользователь может быть владельцем, членом группы или никем.
3. Права доступа к файлу задаются для каждой из этих трех категории пользователей.
4. Существует три базовых права доступа - на чтение, запись и выполнение.
5. Девять базовых прав доступа отображаются в атрибутах файла командой ls -l.
6. Для каталогов права доступа имеют свой смысл: чтение списка файлов, создание и удаление файлов и переход в эту папку соответственно.


### Как задавать права доступа?



1. Новые файлы получают стандартные права доступа, заданные командой umask.
2. Можно изменить владельца и группу файла командой chown.
3. Права доступа к файлу может изменить владелец или рут командой chmod.
4. Права доступа задаются в символьном или в восьмеричном выражении.
5. Можно задать специальные биты прав доступа - SUID, SGID и Sticky-bit.


## Управление пакетами


### Как в Linux распространяются программы?

Выводы:



1. Любая операционная система должна иметь возможность установки сторонних программ.
2. Современные сложные программы состоят из многих файлов и требуют специальной процедуры установки.
3. Поэтому они распространяются в виде программных пакетов.
4. В каждой операционной системе формат пакета свой, даже в разных дистрибутивах разный.
5. Программы могут зависеть друг от друга, поэтому у пакетов тоже могут быть зависимости.
6. Программы также могут распространяться в виде исходного кода.


### Что такое пакет?

Выводы:



1. Пакет содержит всю информацию, которая необходима для установки и работы программы.
2. В виде пакетов распространяются программы, прикладные и системные библиотеки.
3. Кроме самого кода программы в нем содержатся ее ресурсы, а также инструкции для установки.
4. Все дистрибутивы, основанные на Debian, используют deb-пакеты.
5. Семейство RedHat использует пакеты RPM.
6. Один пакет может зависеть от десятков других.


### Что такое пакетный менеджер?

Выводы:



1. Пакетный менеджер - это программа, которая автоматизирует работу с пакетами.
2. В разных дистрибутивах разные пакетные менеджеры.
3. Пакетный менеджер может установить программу из пакета и сам следит за зависимостями.
4. Пакетный менеджер - это консольная программа, но есть графические интерфейсы.
5. Существуют программные контейнеры, типа flatpack, которые не имеют зависимостей, но весят сильно больше.


### Что такое репозитории пакета?

Выводы:



1. Репозиторий - это каталог программных пакетов, как магазины приложений.
2. Производители популярных дистрибутивов поддерживают собственные репозитории.
3. Пакетный менеджер использует репозитории для поиска и установки пакетов, отображения информации.
4. К пакетному менеджеру в системе можно подключить несколько репозиториев.
5. Существуют сторонние репозитории от производителей программ.
6. Каждый дистрибутив может пользоваться репозиториями родственных ему.


### Как в Linux Mint устанавливать программы?

Выводы:



1. Команда apt install &lt;packagename> установит программу из репозитория.
2. Операции с пакетами обычно требуют привилегий суперпользователя, поэтому sudo apt...
3. Для установки программы нужно знать название ее пакета.
4. Программа установится только если она есть хотя бы в одном подключенном репозитории.
5. Можно указать несколько программ через пробел.
6. Обычно при начале работы с дистрибутивом устанавливают программы по списку.
7. Опция -y подавляет запрос подтверждения, полезно в скриптах.


### Какие еще операции с пакетными менеджерами нужно знать?

Выводы:



1. Команда apt remove &lt;packagename> удаляет пакет. Также можно указать несколько пакетов.
2. Команда apt purge удаляет пакет и все связанные файлы, неиспользуемые зависимости.
3. Команда apt update обновляет список репозиториев, надо выполнять как можно чаще.
4. Команда apt install &lt;packagename> обновляет пакет до новейшей версии.
5. Команда apt upgrade обновляет все установленные пакеты. Может работать очень медленно.
6. Команда apt dist-upgrade обновляет сам дистрибутив до новейшей версии.
7. Команда apt search [keyword] позволяет найти нужный пакет по ключевому слову.


## Управление процессами


### Что такое процесс?



1. Процесс - это программа, запущенная на выполнение.
2. Одна программа может порождать несколько процессов.
3. Одну программу можно запустить несколько раз.
4. Все процессы выполняются независимо друг от друга.
5. У каждого процесса есть свой выделенный участок памяти.


### Что такое многозадачность?



1. В каждый момент в операционной системе выполняется множество процессов.
2. На одном ядре ЦП может выполняться только одна последовательность инструкций одновременно.
3. Операционная система постоянно переключает процессы на выполнение.
4. Иногда переключение происходит добровольно, но чаще - нет.
5. Сам процесс не имеет контроля над тем, когда его переключат.
6. Большинство современных операционных систем реализуют вытесняющую многозадачность.


### В каких состояниях может находиться процесс?



1. Создание нового процесса - довольно длительный для компьютера процесс.
2. После создания процесс в состоянии готовности становится в очередь.
3. Когда очередь подходит, он начинает выполняться на процессоре.
4. Если во время выполнения процесс завершается, ОС его уничтожает и очищает память.
5. Если во время выполнения проходит квант времени, ОС опять ставит его в очередь.
6. Если во время выполнения процесс блокируется, ОС его приостанавливает. 
7. Когда придет внешнее событие, разблокирующее процесс, он опять становится в состояние готовности.
8. Существует много разных реализаций очереди процессов, с приоритетами и без.


### Какую информацию ОС хранит о процессе?



1. У каждого процесса есть численный идентификатор.
2. С каждым процессом связан пользователь-владелец.
3. У каждого процесса (за исключением одного) есть процесс-родитель.
4. ОС хранит информацию о процессах в специальном разделе - файловой системе /proc.
5. ОС запоминает статистическую информацию о потреблении процессами ресурсов.
6. Большая часть информации о процессах скрыта. Например, открытые файловые дескрипторы.


### Как процессы связаны с терминалами?



1. Каждый процесс при запуске связывается с определенным терминалом.
2. Это может быть виртуальный терминал, графическая программа или эмулятор.
3. Это связывание используется для разделения потоков ввода-вывода.
4. При запуске процесса терминал блокируется.
5. Некоторые процессы не связаны с терминалами.


### Как посмотреть выполняемые процессы?



1. Самая распространенная команда - ps. 
2. По умолчанию она показывает только процессы текущего пользователя, связанные с текущим терминалом.
3. Полный список процессов можно посмотреть командой ps aux.
4. Интерактивную информацию о процессах показывает программа top.
5. Существует улучшенный вариант top - htop.
6. С помощью htop можно проводить полноценный мониторинг системы, выполнять операции над процессами.


### Что такое процессы-демоны?



1. Демоны не связаны с терминалами и не имеют пользовательского интерфейса.
2. Они используются для выполнения фоновых операций.
3. Большинство демонов - системные службы.
4. Можно создать свою собственную программу-демона.
5. Существует специальная программа для управления службами.


### Как снять процесс?



1. Завершить текущий процесс в терминале можно комбинацией Ctrl + C.
2. Интерактивные программы нужно стараться завершать штатно.
3. Снять индивидуальный процесс можно с помощью программы kill.
4. Формально, это послание сигнала процессу.
5. Для мягкого завершения используется сигнал 15.
6. Для того, чтобы снять зависший процесс может понадобится сигнал 9.
7. Убить все процессы по имени команды можно командой killall.


### Как связаны родитель и потомок?



1. Для каждого процесса, кроме самого первого существует процесс-родитель.
2. Поэтому процессы в Linux образуют дерево.
3. При завершении родителя, все его потомки тоже завершаются.
4. Процесс наследует от родителя пользователя и права доступа.
5. В редких случаях пользователь может измениться.


### Что такое приоритет процесса?



1. Приоритет процесса - это число, определяющее, как часто процесс будет получать процессорное время.
2. В Linux также используется число nice value - величина, обратная приоритету.
3. Nice измеряется от -20 (высший приоритет) до 19 (низший приоритет).
4. Пользователь может понизить приоритет своих процессов.
5. Повысить приоритет может только суперпользователь.
6. Можно запустить процесс с нестандартным приоритетом командой nice -n. 
7. Можно изменить приоритет уже выполняемого процесса командой renice -n.
8. Эти команды задают числа, которые прибавляются к nice value.


### Что такое фоновые процессы?



1. Можно запустить процесс без привязки к терминалу, в фоновом режиме с помощью &.
2. Если мы хотим перевести процесс в состояние остановленный, используется сочетание клавиш «Ctrl + z».
3. Можем переместить остановленный процесс на передний план командой fg.
4. Можно продолжить выполнение остановленного процесса в фоновом режиме командой bg.
5. Используя команду jobs мы можем получить список остановленных и фоновых процессов.


## -Управление запуском системы


### Как происходит загрузка компьютера?



1. 


### Какие функции выполняет загрузчик операционной системы?


### Что такое инициализатор системы?


### Что такое службы Linux?


### Как просмотреть установленные службы?


### Как создать службу из программы?


### Какова структура модуля?


### Как настроить автозагрузку модуля?


## -Работа с файловой системой


### Что такое раздел жесткого диска?


### Зачем нужны разные разделы и файловые системы?


### Как разбить диск для Linux?


### Что такое монтирование файловых систем?


### Как настроить автоматическое монтирование?


### Зачем нужен раздел swap?


### Как посмотреть информацию о разделах и свободном месте?


### Как переразбить диск?


### Как перенести каталог на новый раздел?

df -h

free -m

du


## -Основы скриптов на Bash


### Зачем нужны скрипты на bash?


## -Средства обработки текста


### Как работать с большими текстовыми файлами?


### Как искать информацию в тексте?


### Зачем нужен текстовый процессор sed?


### Для чего применяется текстовый процессор awk?
