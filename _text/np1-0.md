---
title: "Основы сетевого программирования"
# section: os
---



### Основные понятия сетевого программирования


#### Чем сетевые приложения отличаются от обычных?



![alt_text](/assets/images/np_text/np10-1.png "image_tooltip")


**Сетевыми приложениями мы будем называть любые приложения, которые обмениваются данными, используя компьютерную сеть.** Это довольно широкое определение, и, конечно, мы не сможем рассмотреть все многообразие обширного мира сетевых технологий, который, вдобавок развивается очень быстро и новые технологии, приемы и методики появляются чуть ли не каждый день. Поэтому в данном пособии мы сконцентрируемся на освоении базовых схем обмена информацией по сети, которые лежат в основе всех более продвинутых вещей. Используя полученные знания вы сами сможете строить все более и более сложные схемы взаимодействия разных приложений и разных компонентов одного приложения по сети.

**В настоящее время все более или менее развитые приложения являются сетевыми в той или иной мере**. 

Сетевые приложения могут обмениваться информацией с другими, сторонними приложениями либо строить взаимодействие по сети между компонентами одного и того же приложения, написанного одним автором или одной командой. 


#### Что позволяют делать сетевые приложения?



1. Обращение к сторонним сервисам
2. Создание публичного сервиса
3. Многопользовательские приложения
4. Автоматические обновления
5. Удаленное хранение данных
6. Омниканальность

Возможность обмениваться данными по сети открывает перед разработчиком широкий круг возможностей.

**Вы можете обращаться к сторонним сервисам, имеющим открытое API.** Сегодня существует множество сервисов, постоянно действующих в сети и предоставляющих способ обмена данными в автоматизированном формате через специальную схему взаимодействия, то есть публичный интерфейс, или API. Например, ваша программа может обратиться к погодному сервису и получить данные о погоде в определенном месте или городе. 

**Также вы можете сами разработать такой публичный сервис.** Если ваше приложение может выдавать информацию по запросу неограниченному кругу лиц, вы можете опубликовать в Интернете приложение, которое будет обрабатывать входящие соединения и отвечать на запросы. Нужно только спроектировать API вашего сервиса, реализовать и задокументировать его.

**Можно строить распределенные приложения**. Сейчас довольно распространены приложения, основой функционирования которых является взаимодействие множества компонентов, запущенных на совершенно независимых компьютерах сети. Так работают, например, пиринговые сети, системы распределенных вычислений или ботнеты.

**Добавьте к любой вашей программе возможность самостоятельно обновляться по сети.** Почти все программы имеют подсистему автоматической и регулярной проверки сервера разработчика программы на предмет выхода новой версии. При наличии такой можно предложить пользователю скачать ее, либо обновиться самостоятельно.

**Можно использовать централизованную схему клиент-сервер.** В таком случае ваша программа может быть разделена на две логические части - клиентскую, которая запускается на компьютере пользователя и предоставляет ему интерфейс, и серверную, которая работает на сервере, принадлежащем разработчику, и может заниматься, например, доступом к базе данных. Логика работы программы тоже может быть разделена на две части.

**Можно организовывать централизованное хранилище данных.** Это удобно, если, например,  вам нужно собирать данные от пользователей вашей программы в одном месте, либо предоставить пользователям возможность обмениваться сообщениями. 

Если вы организуете взаимодействие с клиентами посредством нескольких каналов, можно позаботиться об **омниканальности** - возможности сохранять информацию о всех взаимодействиях с пользователем по любым каналам, создавая ощущение бесшовности. Такую схему активно используют, например, банки. Вы можете зайти в мобильное приложение, совершить там какую-то операцию, а затем зайти в личный кабинет на веб-сайте банка и продолжить работу с того же места.


#### В чем сложности написания приложений?

Нужно знать основы организации компьютерной сети.

Для некоторых приложений необходимо знать особенности конкретных сетевых протоколов, например, HTTP.

Необходимо также отдельно заботиться о согласованности обмена информацией между компонентами приложения. 

Написание многопоточных приложений требует специальных усилий по обеспечению потокобезопасности.

Также не нужно забывать о вопросах безопасности, конфиденциальности, валидации получаемых данных.

Также существуют вопросы управления нагрузкой ваших сервисов и сетевой инфраструктуры.

Необходимо также помнить о доступности сети и ограниченности полосы пропускания. 


#### Какие технологии нужно знать для их создания?

Основы программирования

Основы сетей

Основы многопоточности и потокобезопасности

Параллельное программирование

Основы веб-технологий


#### Какие основные подходы к их построению?


![alt_text](/assets/images/np_text/np10-2.png "image_tooltip")


![alt_text](/assets/images/np_text/np10-3.png "image_tooltip")


Есть две главные архитектуры построения сетевых приложений - клиент-серверная и распределенная.

Сервер - это компьютер, программа или процесс, обеспечивающий доступ к информационным ресурсам.

Клиент обычно инициирует соединение и делает запрос к ресурсу.

Клиент-серверная архитектура является централизованной со всеми присущими недостатками и преимуществами.

Распределенная архитектура может обойти некоторые ограничения централизованной.

Распределенные приложения сложнее проектировать и управлять ими.


#### Как связаны сетевые приложения и многопоточность?


![alt_text](/assets/images/np_text/np10-4.png "image_tooltip")


Сетевые технологии неразрывно связаны с написанием многопоточных и многопроцессных приложений. 

Многопоточность - это технология, позволяющая выполнять некоторые выделенные части приложения параллельно, грубо говоря, одновременно, задействуя механизмы обеспечения многозадачности современных операционных систем. 

Многопоточность позволяет строить отзывчивые интерфейсы.

Без многопоточности невозможно писать сервисы, обрабатывающие запросы пользователя параллельно.

Написание многопоточных приложений сильно затрудняет отладку программного обеспечения. 


### Основы взаимодействия через сокеты


#### Что такое TCP-сокеты?


![alt_text](/assets/images/np_text/np10-5.png "image_tooltip")


**Со́кет (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью**.

**Сетевые сокеты - это один из наиболее распространенных механизмов передачи информации между двумя процессами по сети, не требующий специального программного обеспечения.** Например, для создания веб-приложения, которое использует протокол HTTP для взаимосвязи своих компонентов, необходим работающий и правильно настроенный веб-сервер. Для работы сокетов необходимо, чтобы операционная система поддерживала стек протоколов TCP/IP, что справедливо для всех современных операционных систем.

**Сокеты - это самый базовый механизм сетевого взаимодействия программ, абстрагированный от конкретной реализации сети.** Сокеты работают на транспортном уровне модели OSI - там же, где и протокол TCP и UDP.

Каждый сетевой интерфейс IP-сети имеет уникальный в этой сети адрес (IP-адрес). Упрощенно можно считать, что каждый компьютер в сети Интернет имеет собственный IP-адрес. При этом в рамках одного сетевого интерфейса может быть несколько (до 65536) сетевых портов. Для установления сетевого соединения приложение клиента должно выбрать свободный порт и установить соединение с серверным приложением, которое слушает (listen) порт с определенным номером на удаленном сетевом интерфейсе. **Пара IP-адрес и порт характеризуют сокет (гнездо) - начальную (конечную) точку сетевой коммуникации**. 

**Сокеты могут применяться для связи процессов как на удаленной машине, так и на локальной.** В первом случае, естественно, необходимо, чтобы удаленная машина была доступна по сети. Это можно проверить при помощи команды пинг. Во втором случае сокеты могут выступать как механизм межпроцессного взаимодействия. Или вы можете использовать одну машину для всех процессов-компонентов вашей программной системы, например, для отладки в процессе разработки. 

**Для создания соединения TCP/IP необходимо два сокета: один на локальной машине, а другой - на удаленной.** Таким образом, каждое сетевое соединение имеет IP-адрес и порт на локальной машине, а также IP-адрес и порт на удаленной машине. Как правило, порт локальной машины (исходящий порт) не так важен и его номер не особенно используется в практике. Но порт серверного сокета - это важная информация

**Сокеты могут быть клиентские и серверные.** Серверный сокет - это функция в программе, которая сидит на определенном порту и “слушает” входящие соединения. Процедура создания серверного сокета аналогична вводу текста из консоли: программа блокируется до тех пор, пока пользователь не ввел что-то. Когда это случилось, программа разблокируется и может продолжать выполнение и обработку полученных данных. Также и серверный сокет: ждет, когда к нему подключится клиент и тогда продолжает выполнение программы и может считывать данные из сокета (которые послал клиент) и отправлять данные в сокет. Клиентский же сокет, наоборот, сразу пытается подключиться к определенном узлу сети (это может быть локальная машина, или, чаще, удаленный компьютер) и на определенный сетевой порт. Если на этой машине на этом порту “сидит” серверный сокет, то подключение происходит успешно. Если же данный сокет никем не прослушивается, то процедура подключения возвращает ошибку.

**В языке программирования Python существует стандартный модуль socket, который реализует все необходимые функции для организации обмена сообщениями через сокеты.** Для его использования его достаточно импортировать (так как это модуль стандартной библиотеки, устанавливать его не нужно, он идет в поставке с дистрибутивом Python):


```python
import socket
```

Для начала построения сетевого взаимодействия необходимо создать сокет:


```python
sock = socket.socket()
```

Здесь ничего особенного нет и данная часть является общей и для клиентских и для серверных сокетов. Дальше мы будем писать код отдельно для сервера и для клиента. 


#### Какие виды сокетов существуют?


![alt_text](/assets/images/np_text/np10-6.png "image_tooltip")


Существует несколько видов сокетов, которые немного различаются по сфере применения и деталях реализации.

Самыми распространенными являются Интернет-сокеты. Они используются для пересылки информации между процессами. Есть еще сокеты UNIX, они не используют Интернет-протоколы для обмена сообщениями, и используются для организации межпроцессного взаимодействия.

Существуют потоковые и датаграммные сокеты.

Датаграммные сокеты называют “сокеты без соединения”, они используют протокол UDP вместо TCP.

Потоковые сокеты обеспечивают гарантированную  доставку, очередность сообщений, они более надежны. Протокол HTTP использует именно потоковые сокеты для соединения клиента с сервером.

UDP обычно используется для передачи потокового медиа, когда скорость критичнее риска потери единичных пакетов.


#### Каковы правила использования номеров портов?


![alt_text](/assets/images/np_text/np10-7.png "image_tooltip")


IP-адрес или любой другой способ адресации хоста позволяет нам идентифицировать узел сети. Номер порта позволяет указать конкретное приложение на этом хосте, которому предназначен пакет. 

Номер порта нужен, так как на любом компьютере может быть одновременно запущено множество приложений, осуществляющих обмен данными по сети.

Если использовать аналогию с почтовыми адресами, то IP-адрес - это номер дома, а порт - это номер квартиры в этом доме. 

Существует всего 655536 возможных портов. Номер порта - это 16 байт.

Первые 1024 являются “системными” и используются стандартными приложениями.

Существует общепринятое соглашение, какие сетевые службы используют системные порты.

Для использования системных портов обычно требуются повышенные привилегии. 

Остальные порты могут использоваться совершенно произвольно.

Помните, что если вы пытаетесь использовать занятый порт, то это спровоцирует программную ошибку. 

Сетевые администраторы могут в целях безопасности блокировать соединения на некоторые порты. 


#### Почему мы не начинаем с прикладных уровней?


![alt_text](/assets/images/np_text/np10-8.png "image_tooltip")


Использование сокетов позволяет строить приложения, обменивающиеся данными по сети, но при этом не требующие специального программного обеспечения.

Чтобы написать веб-приложение, нам нужен веб-клиент и веб-сервер, настроенные и готовые к работе. Такая же ситуация с любой другой службой Интернета.

Сокеты - это компромиссный вариант.

Более высокоуровневые механизмы требуют установленного и настроенного специального программного обеспечения. Даже если вы планируете использовать в профессиональной деятельности прикладные протоколы, все они в основе своей работы используют механизм сокетов, так что его понимание будет полезно всем.

Более низкоуровневые протоколы не абстрагируются от конкретной реализации сети.


#### Как организуется обмен данными через сокеты?


![alt_text](/assets/images/np_text/np10-9.png "image_tooltip")


Для соединения необходимо создать два сокет - серверный и клиентский. Они могут быть созданы в разных процессах.

Работа с сокетами происходит через механизм системных вызовов. Все эти вызовы аналогичны вызовам, осуществляющим операции с файлами. Список этих вызовов определен в стандарте POSIX и не зависит от используемой операционной системы или языка программирования. 

Первым создается серверный сокет. Он назначается на определенный порт и начинает его ожидать (прослушивать) входящие соединения.

Прослушивание порта - это блокирующая операция.

После этого создается клиентский сокет. Клиент может подключиться к серверному сокету по адресу и номеру порта. Если этот порт является открытым (то есть его прослушивает какой-то процесс), то произойдет соединение и на сервере выполнится метод accept.

После этого устанавливается двунаправленное соединение, которое можно использовать для чтения и записи данных. Интерфейс взаимодействия с сокетом очень похож на файловые операции, только при записи информации, она не сохраняется на диск, а посылается в сокет, откуда может быть прочитана другой стороной.

После соединения можно отправлять или получать информацию из сокета. Чтение информации из сокета - это блокирующая операция.


### Простейшие клиент и сервер


#### Что мы хотим сделать?


![alt_text](/assets/images/np_text/np10-10.png "image_tooltip")


Мы хотим реализовать простейший пример сетевого взаимодействия - пару процессов, которые связываются между собой.

Мы будем организовывать один набор сокетов. Так что один из них должен быть клиентским, а другой - серверным. 

Поэтому один процесс мы будем называть сервером, а другой - клиентом. Однако, такое разделение условно и одна и та же программа может выступать и клиентом для одного взаимодействия и сервером - для другого. **Можно сказать, что клиент и сервер - это просто роли в сетевом взаимодействии.**

Инициирует соединение клиент.

Первым должен быть запущен сервер, а затем клиент.


#### Как создать такой сервер?


```python
#!/usr/bin/env python
import socket
sock = socket.socket()
sock.bind(('', 9090))
sock.listen(1)
conn, addr = sock.accept()
print 'connected:', addr
while True:
    data = conn.recv(1024)
    if not data:
        break
    conn.send(data.upper())
conn.close()
```

Для начала нам нужно определиться, какой порт будет использовать наш сервер.

Еще один параметр - сетевой интерфейс. Если оставить эту строку пустой, то сервер будет доступен для всех сетевых интерфейсов. 

Для примера выберем порт 9090. 

**Теперь свяжем наш сокет с данными хостом и портом с помощью метода bind**, которому передается кортеж, первый элемент (или нулевой, если считать от нуля) которого — хост, а второй — порт. Обратите внимание, что метод bind принимает кортеж из двух элементов - имя хоста и номер порта.


```python
sock.bind(('', 9090))
```

Теперь у нас все готово, чтобы принимать соединения.** С помощью метода listen мы запустим для данного сокета режим прослушивания.** Метод принимает один аргумент — максимальное количество подключений в очереди. Установим его в единицу. 


```python
sock.listen(1)
```

Обратите внимание, что это блокирующая операция.

Теперь, мы можем принять подключение с помощью метода accept, который возвращает кортеж с двумя элементами: новый сокет и адрес клиента. Именно этот сокет и будет использоваться для приема и посылке клиенту данных. Так как данная операция идет после listen, она будет выполнена только тогда, когда сервер получит входящее соединение от клиента. 


```python
conn, addr = sock.accept()
```

Так мы установили с клиентом связь и можем с ним общаться. **В данном простейшем примере мы будем получать данные от клиента небольшими порциями в бесконечном цикле, чтобы получить любой объем данных, который клиент может нам послать**. Чтобы получить данные нужно воспользоваться методом recv, который в качестве аргумента принимает количество байт для чтения. Мы будем читать порциями по 1024 байт (или 1 кб):


```python
while True:
    data = conn.recv(1024)
    if not data:
        break
    conn.send(data.upper())
```

**Метод recv() тоже является блокирующей операцией.**

**Для общения с клиентом мы используем сокет, который получили в результате выполнения метода accept.** Мы в бесконечном цикле принимаем 1024 байт данных с помощью метода recv. Если данных больше нет, то этот метод ничего не возвращает. Таким образом мы можем получать от клиента любое количество данных.

**Дальше в нашем примере для наглядности мы что-то сделаем с полученными данными и отправим их обратно клиенту.** Например, с помощью метода upper у строк вернем клиенту строку в верхнем регистре.

**После получения порции данных и отсылки их обратно клиенту можно и закрыть соединение**:


```python
conn.close()
```

На этом написание сервера закончено. Он принимает соединение, принимает от клиента данные, возвращает их в виде строки в верхнем регистре и закрывает соединение. 


#### Как создать такой клиент?


```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import socket

sock = socket.socket()
sock.connect(('localhost', 9090))
sock.send('hello, world!')

data = sock.recv(1024)
sock.close()

print data
```


Клиентское приложение еще короче. 

Клиент использует точно такой же объект socket.

Вместо прослушивания порта мы сразу осуществляем соединение. Для этого указывается IP-адрес хоста, на котором запущен сервер и номер порта, который он прослушивает. 

При неуспешном соединении метод listen выбросит исключение. Существует несколько причин - хост может быть недоступен по сети, порт может не прослушиваться никаким процессом.

Послание данных в сокет осуществляется методом send.

Дальше мы читаем 1024 байт данных и закрываем сокет. Для большей надежности чтение данных можно организовать так же как на сервере - в цикле. 

